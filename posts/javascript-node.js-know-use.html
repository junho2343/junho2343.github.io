<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="/favicon/social_preview.jpeg"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="google-site-verification" content="UvtxWDaEi6g_ZkTZOmiWKdYOwB5WgIEEdhSJ6DWnoVc"/><title>JavaScript / Node.js 잘 알고 사용하기 | 문준호</title><meta property="og:image" content="/assets/blog/javascript-node.js-know-use/cover.jpeg"/><meta name="description" content="JavaScript / Node.js의 동작 원리를 통해 코드의 흐름이 어떤 방식으로 진행되며, Single Thread, Event Loop, Non-Blocking I/O에 대해 알고 확장성 있는 애플리케이션을 만들기 위해 어떤 부분을 조심해야 하는지 알아봅시다."/><meta name="next-head-count" content="15"/><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css"/><link rel="preload" href="/_next/static/css/64f9012ef3612681.css" as="style"/><link rel="stylesheet" href="/_next/static/css/64f9012ef3612681.css" data-n-g=""/><link rel="preload" href="/_next/static/css/91ec727b30312911.css" as="style"/><link rel="stylesheet" href="/_next/static/css/91ec727b30312911.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-0380034b89bc30d6.js" defer=""></script><script src="/_next/static/chunks/framework-d51ece3d757c7ed2.js" defer=""></script><script src="/_next/static/chunks/main-f8c0f8da2c690304.js" defer=""></script><script src="/_next/static/chunks/pages/_app-51fe4f35ec38a006.js" defer=""></script><script src="/_next/static/chunks/2015-e9026f5023475b2b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-44bc3dcdddf1a9f1.js" defer=""></script><script src="/_next/static/pM8n3hZBguJ-JIdhB0EWY/_buildManifest.js" defer=""></script><script src="/_next/static/pM8n3hZBguJ-JIdhB0EWY/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex justify-center w-full border-b border-b-[#d8e0e7] pt-10 pb-2 sticky top-0 z-10 bg-white"><div class="w-full max-w-4xl min-w-[320px] undefined px-4"><a class="pr-4 font-[400]" href="/about">About</a><a class="pr-4 font-[400]" href="/">Posts</a></div></div><div class="min-h-screen flex items-center flex-col relative"><div class="w-full max-w-4xl min-w-[320px] undefined px-4"><main><div class=""><div class="max-w-2xl pt-14 mx-auto relative"><article class="mb-32"><div class="pb-3"><h1>JavaScript / Node.js 잘 알고 사용하기</h1><div class="mt-1 mb-6"><span class="bg-slate-100 p-1.5 mr-1 rounded text-xs font-normal">2023-02-10</span><span class="bg-slate-100 p-1.5 mr-1 rounded text-xs font-normal">#<!-- -->JavaScript</span><span class="bg-slate-100 p-1.5 mr-1 rounded text-xs font-normal">#<!-- -->Node.js</span></div><div class="aspect-video sm:mx-0"><img src="/assets/blog/javascript-node.js-know-use/cover.jpeg" alt="" class="w-full h-full object-cover"/></div></div><div class="markdown-styles_markdown-body__gSZH5"><blockquote>
<p>JavaScript / Node.js의 동작 원리를 통해 코드의 흐름이 어떤 방식으로 진행되며, Single Thread, Event Loop, Non-Blocking I/O에 대해 알고 확장성 있는 애플리케이션을 만들기 위해 어떤 부분을 조심해야 하는지 알아봅시다.</p>
</blockquote>
<h2 id="브라우저에서의-javascript-동작-원리부터">브라우저에서의 JavaScript 동작 원리부터</h2>
<p>우선 JavaScript 코드는 Engine을 통해 실행되며, 우리가 아는 브라우저나 Node.js 안에 내재되어 있습니다. 그럼 JavaScript Engine은 어떤 역할을 담당할까요?</p>
<p><img src="/assets/blog/javascript-node.js-know-use/1.png" alt="Chrome, Node.js 에 내재된 V8 JavaScript Engine"/><span>Chrome, Node.js 에 내재된 V8 JavaScript Engine</span></p>
<p>JavaScript Engine은 JavaScript 코드를 컴퓨터가 이해할 수 있는 언어로 변환시켜주며, 주요 구성 요소를 단순화해 보자면 메모리 할당이 일어나는 <strong>Memory Heap</strong>과 코드 실행에 따라 호출 스택이 쌓이는 <strong>Call Stack</strong>이 있습니다.</p>
<p>하지만 저희가 흔히 아는 비동기식 코드를 위한 setTimeout 이나 HTTP 요청을 관리하는 코드들, JavaScript 의 동작 원리에 항상 언급되는 Event Loop는 찾아볼 수 없습니다.</p>
<!-- -->
<p><img src="/assets/blog/javascript-node.js-know-use/2.png" alt="Chrome 브라우저"/><span>Chrome 브라우저</span></p>
<p>위에서 언급한 요소들은 <strong>JavaScript Engine</strong>이 아닌 <strong>JavaScript Runtime</strong>에 내재되어 있는걸 볼 수 있으며, 어떤 식으로 연결되어 움직이는지 차근차근 알아봅시다.</p>
<blockquote>
<p>💡 JavaScript Runtime이란?</p>
<p>JavaScript Engine이 실행되는 환경이며, 대표적으로 브라우저나 Node.js가 JavaScript Runtime이라고 불립니다.</p>
</blockquote>
<h2 id="single-thread--one-call-stack">Single Thread == One Call Stack</h2>
<p>JavaScript는 <strong>Single Thread</strong> 프로그래밍 언어입니다. 이 말은 한 번에 하나의 <strong>Call Stack</strong> 만을 가지며, 하나의 프로그램은 <u>동시에 하나의 코드</u>만 실행할 수 있다는 말인데요. 이게 무엇을 의미하는지 시각화하여 살펴봅시다.</p>
<blockquote>
<p>💡 Call Stack이란?</p>
<p>LIFO 형태의 Stack 자료구조 형식으로, 여러 함수를 호출하는 스크립트에서 자신의 위치를 기록/추적하는데 사용됩니다.</p>
</blockquote>
<p><img src="/assets/blog/javascript-node.js-know-use/3.gif" alt=""/><span></span></p>
<p>위 GIF를 보면, 함수를 실행하기 위해 Call Stack에 쌓고, 함수의 실행이 끝날 때 나중에 쌓인 스택부터 제거되는 걸 볼 수 있습니다. 이를 통해 <strong>코드 실행의 흐름</strong>을 알 수 있죠.</p>
<p>그렇다면 오래 걸리는 코드가 Call Stack에 남아있다면 어떻게 될까요?</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span></code><code class="language-javascript" style="white-space:pre">console.log(&quot;start&quot;);

const wakeUpTime = Date.now() + 3000;

while (Date.now() &lt; wakeUpTime) {}

console.log(&quot;end&quot;);</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<p><img src="/assets/blog/javascript-node.js-know-use/4.gif" alt=""/><span></span></p>
<p>브라우저에서 2초 동안 while 문을 계속 실행하여 Call Stack을 비우지 않을 경우, 그동안의 모든 작업이 멈추게 됩니다. 2초가 지나서야 클릭 이벤트가 실행되는걸 볼 수 있죠. 이는 위에서 말했듯 JavaScript가 <strong>Single Thread</strong>를 기반으로 동작하여 <u>동시에 하나의 코드</u>만 실행할 수 있기 때문입니다.</p>
<p>또한 이렇게 코드가 느리게 동작될 경우 <code>Blocking</code> 된다고 표현합니다. <code>Blocking</code>/<code>Non-Blocking</code>은 <u>프로세스의 유휴 상태</u>에 대한 개념으로, 프로세스가 앞으로 해야 할 작업을 할 수 있는가에 따라 정해지죠.</p>
<p>그래서 JavaScript에서는 Call Stack에 느린 동작이 남아있을 경우 <code>Blocking</code>된다고 말할 수 있을 것 같습니다.</p>
<h2 id="javascript-runtime과-event-loop">JavaScript Runtime과 Event Loop</h2>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span></code><code class="language-javascript" style="white-space:pre">console.log(&quot;start&quot;);

setTimeout(function cb() {
  console.log(&quot;1 seconds after&quot;);
}, 1000);

console.log(&quot;end&quot;);</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<p>그렇다면 우리가 흔히 사용하는 setTimeout 함수는 어떻게 동작할까요?</p>
<p>누구나 “start”, “end”가 먼저 콘솔에 노출되고 1초 후 “1 seconds after”가 보인다고 생각하실 겁니다. 하지만 1초를 기다리는 동안 브라우저가 멈추는 현상은 없죠.</p>
<p>여기에서 <code>JavaScript Runtime</code>의 역할과 <code>Event Loop</code>의 개념이 나오게 됩니다.</p>
<p><img src="/assets/blog/javascript-node.js-know-use/2.png" alt=""/><span></span></p>
<p>위에서 사용했던 그림을 다시 보면, 브라우저(<strong>JavaScript Runtime</strong>)는 <strong>JavaScript Engine</strong> 외에도 많은 것들을 제공합니다. setTimout과 같은 다양한 Web APIs의 기능들을 <code>Multi Thread</code> 환경에서 처리하며, 그 후에 실행할 콜백함수들을 관리하죠.</p>
<p><strong>JavaScript Runtime</strong>에서 제공하는 함수들은 대부분 <code>Non-Blocking</code>하며 <code>비동기적</code>으로 제공됩니다. <code>비동기적</code>이라는 말은 <code>Blocking</code>/<code>Non-Blocking</code>과는 다르며 <u>프로세스의 수행 순서</u> 보장에 대한 개념으로, 코드가 위에서 아래의 흐름이 지켜지는지에 따라 정해집니다.</p>
<p>setTimeout 함수의 예제는 수행 순서가 위에서 아래로 일정하지 않으니 <code>비동기적</code>이라고 할 수 있습니다.</p>
<p><img src="/assets/blog/javascript-node.js-know-use/5.gif" alt=""/><span></span></p>
<p>실행되는 과정을 좀 더 자세히 보면, setTimeout 함수는 <strong>브라우저</strong>에서 제공하므로 JavaScript 코드가 처리되는 <strong>Call Stack</strong>과는 별개로 다른 영역에서 처리되며, 그 후 실행할 작업을 <strong>Callback Queue</strong>에 쌓게 됩니다.</p>
<p>이때 <code>Event Loop</code>는 <strong>Call Stack</strong>이 비어있다면 <strong>Callback Queue</strong>의 작업을 가져와 실행할 수 있게 해줍니다.</p>
<h2 id="그렇다면-nodejs의-동작-원리는">그렇다면 Node.js의 동작 원리는?</h2>
<p>JavaScript 코드가 브라우저에서 동작되는 원리를 먼저 설명한 이유는, Node.js에서 동작되는 원리와 세부적인 단계는 다르지만 개념적으론 같기 때문입니다.</p>
<p>그럼 어떤 부분에서 차이가 있을까요?</p>
<p><img src="/assets/blog/javascript-node.js-know-use/5.png" alt=""/><span></span></p>
<p>브라우저에서 제공되는 Web APIs의 기능들 대신 시스템 디스크나 네트워크와 상호작용하는 I/O 작업들을 <code>Non-Blocking</code>하며 <code>비동기적</code>으로 제공합니다. (그렇지 않은 함수들도 있습니다.)</p>
<p>그렇기 때문에 다른 서버와 통신하거나, 데이터베이스에 접근하고, 파일에 접근하는 등의 I/O 작업을 JavaScript Engine 밖에서 수행하며 <strong>Process</strong>가 <code>Blocking</code> 되지 않도록 합니다.</p>
<p>이는 Node.js가 <strong>Single Thread</strong> 기반의 <code>Non-Blocking I/O</code> 모델이라고 불리는 이유입니다.</p>
<p><img src="/assets/blog/javascript-node.js-know-use/6.png" alt=""/><span></span></p>
<p>또 다른 점으로는 브라우저보다 더 많은 FIFO 대기열(Queue)을 가지며, Event Loop가 각 단계를 순회하며 작업을 수행합니다.</p>
<h2 id="결론">결론</h2>
<p>위에서 보여드린 브라우저나 Node.js의 구조는 이해를 돕기 위해 많은 것들을 생략하여 간단하게 노출한 것들입니다.</p>
<p>전달하고자 했던 내용은 전반적인 JavaScript 코드의 흐름과 동작 원리이며, JavaScript를 잘 사용하기 위해서는 <strong>Single Thread</strong> 로 동작하는 <strong>JavaScript Engine</strong>의 <strong>Call Stack</strong>에 지연되는 작업을 최소화하여 <strong>process</strong>가 <code>Blocking</code> 되지 않도록 = <code>Event Loop</code> 가 멈추지 않도록 해야 합니다.</p></div><div class="mt-20"><div class="markdown-styles_markdown-body__gSZH5"><h2>Reference</h2><ul><li>어쨌든 이벤트 루프는 무엇입니까? | Philip Roberts | JSConf EU<ul><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></li></ul></li><li>Don&#x27;t Block the Event Loop (or the Worker Pool)<ul><li><a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" target="_blank">https://nodejs.org/en/docs/guides/dont-block-the-event-loop/</a></li></ul></li><li>Overview of Blocking vs Non-Blocking<ul><li><a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" target="_blank">https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/</a></li></ul></li><li>[10분 테코톡] 유세지의 Node.js<ul><li><a href="https://www.youtube.com/watch?v=A04zlpL1Uw4" target="_blank">https://www.youtube.com/watch?v=A04zlpL1Uw4</a></li></ul></li><li>Don&#x27;t block the event loop! 매끄러운 경험을 위한 JavaScript 비동기 처리<ul><li><a href="https://engineering.linecorp.com/ko/blog/dont-block-the-event-loop/" target="_blank">https://engineering.linecorp.com/ko/blog/dont-block-the-event-loop/</a></li></ul></li><li>Node.js, lots of ways to block your event-loop (and how to avoid it)<ul><li><a href="https://medium.com/voodoo-engineering/node-js-lots-of-ways-to-block-your-event-loop-and-how-to-avoid-it-b41f41deecf5" target="_blank">https://medium.com/voodoo-engineering/node-js-lots-of-ways-to-block-your-event-loop-and-how-to-avoid-it-b41f41deecf5</a></li></ul></li><li>How JavaScript works: an overview of the engine, the runtime, and the call stack<ul><li><a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a></li></ul></li><li>Node.js는 어떻게 동작하는가<ul><li><a href="https://yceffort.kr/2020/10/how-node-js-works" target="_blank">https://yceffort.kr/2020/10/how-node-js-works</a></li></ul></li><li>Javascript 동작원리 (Single thread, Event loop, Asynchronous)<ul><li><a href="https://medium.com/@vdongbin/javascript-작동원리-single-thread-event-loop-asynchronous-e47e07b24d1c" target="_blank">https://medium.com/@vdongbin/javascript-작동원리-single-thread-event-loop-asynchronous-e47e07b24d1c</a></li></ul></li><li>자바스크립트와 이벤트 루프<ul><li><a href="https://meetup.nhncloud.com/posts/89" target="_blank">https://meetup.nhncloud.com/posts/89</a></li></ul></li></ul></div></div></article><div></div><div class="absolute right-0 top-3"><a href="https://hits.seeyoufarm.com"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fjunho2343.github.io%2Fhit-counter%2Fjavascript-node.js-know-use&amp;count_bg=%230366D6&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=&amp;edge_flat=false"/></a></div></div></div></main></div></div><div class="w-full h-20 mt-10 flex justify-center border-t border-t-[#d8e0e7] bg-[#f6f9fc] "><div class="w-full max-w-4xl min-w-[320px] flex items-center px-4"><span class="text-[#8898a9] font-[300]">© Moon Junho. 2022</span><a href="https://github.com/junho2343" target="_blank"><img src="/assets/icon_github_logo.svg" alt="" class="pl-4"/></a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript / Node.js 잘 알고 사용하기","date":"2023-02-10","slug":"javascript-node.js-know-use","content":"\n\u003e JavaScript / Node.js의 동작 원리를 통해 코드의 흐름이 어떤 방식으로 진행되며, Single Thread, Event Loop, Non-Blocking I/O에 대해 알고 확장성 있는 애플리케이션을 만들기 위해 어떤 부분을 조심해야 하는지 알아봅시다.\n\n## 브라우저에서의 JavaScript 동작 원리부터\n\n우선 JavaScript 코드는 Engine을 통해 실행되며, 우리가 아는 브라우저나 Node.js 안에 내재되어 있습니다. 그럼 JavaScript Engine은 어떤 역할을 담당할까요?\n\n![Chrome, Node.js 에 내재된 V8 JavaScript Engine](/assets/blog/javascript-node.js-know-use/1.png)\n\nJavaScript Engine은 JavaScript 코드를 컴퓨터가 이해할 수 있는 언어로 변환시켜주며, 주요 구성 요소를 단순화해 보자면 메모리 할당이 일어나는 **Memory Heap**과 코드 실행에 따라 호출 스택이 쌓이는 **Call Stack**이 있습니다.\n\n하지만 저희가 흔히 아는 비동기식 코드를 위한 setTimeout 이나 HTTP 요청을 관리하는 코드들, JavaScript 의 동작 원리에 항상 언급되는 Event Loop는 찾아볼 수 없습니다.\n\n\u003c!-- \u003cdiv\u003e\n\n![Chrome 브라우저의 구성 요소](/assets/blog/javascript-node.js-know-use/2.png)\n\n\u003cdiv class=\"text-sm\"\u003eChrome 브라우저의 구성 요소\u003c/div\u003e\n\u003c/div\u003e --\u003e\n\n![Chrome 브라우저](/assets/blog/javascript-node.js-know-use/2.png)\n\n위에서 언급한 요소들은 **JavaScript Engine**이 아닌 **JavaScript Runtime**에 내재되어 있는걸 볼 수 있으며, 어떤 식으로 연결되어 움직이는지 차근차근 알아봅시다.\n\n\u003caside\u003e\n\n💡 JavaScript Runtime이란?\n\nJavaScript Engine이 실행되는 환경이며, 대표적으로 브라우저나 Node.js가 JavaScript Runtime이라고 불립니다.\n\n\u003c/aside\u003e\n\n## Single Thread == One Call Stack\n\nJavaScript는 **Single Thread** 프로그래밍 언어입니다. 이 말은 한 번에 하나의 **Call Stack** 만을 가지며, 하나의 프로그램은 \u003cu\u003e동시에 하나의 코드\u003c/u\u003e만 실행할 수 있다는 말인데요. 이게 무엇을 의미하는지 시각화하여 살펴봅시다.\n\n\u003caside\u003e\n\n💡 Call Stack이란?\n\nLIFO 형태의 Stack 자료구조 형식으로, 여러 함수를 호출하는 스크립트에서 자신의 위치를 기록/추적하는데 사용됩니다.\n\n\u003c/aside\u003e\n\n![](/assets/blog/javascript-node.js-know-use/3.gif)\n\n위 GIF를 보면, 함수를 실행하기 위해 Call Stack에 쌓고, 함수의 실행이 끝날 때 나중에 쌓인 스택부터 제거되는 걸 볼 수 있습니다. 이를 통해 **코드 실행의 흐름**을 알 수 있죠.\n\n그렇다면 오래 걸리는 코드가 Call Stack에 남아있다면 어떻게 될까요?\n\n```javascript\nconsole.log(\"start\");\n\nconst wakeUpTime = Date.now() + 3000;\n\nwhile (Date.now() \u003c wakeUpTime) {}\n\nconsole.log(\"end\");\n```\n\n![](/assets/blog/javascript-node.js-know-use/4.gif)\n\n브라우저에서 2초 동안 while 문을 계속 실행하여 Call Stack을 비우지 않을 경우, 그동안의 모든 작업이 멈추게 됩니다. 2초가 지나서야 클릭 이벤트가 실행되는걸 볼 수 있죠. 이는 위에서 말했듯 JavaScript가 **Single Thread**를 기반으로 동작하여 \u003cu\u003e동시에 하나의 코드\u003c/u\u003e만 실행할 수 있기 때문입니다.\n\n또한 이렇게 코드가 느리게 동작될 경우 `Blocking` 된다고 표현합니다. `Blocking`/`Non-Blocking`은 \u003cu\u003e프로세스의 유휴 상태\u003c/u\u003e에 대한 개념으로, 프로세스가 앞으로 해야 할 작업을 할 수 있는가에 따라 정해지죠.\n\n그래서 JavaScript에서는 Call Stack에 느린 동작이 남아있을 경우 `Blocking`된다고 말할 수 있을 것 같습니다.\n\n## JavaScript Runtime과 Event Loop\n\n```javascript\nconsole.log(\"start\");\n\nsetTimeout(function cb() {\n  console.log(\"1 seconds after\");\n}, 1000);\n\nconsole.log(\"end\");\n```\n\n그렇다면 우리가 흔히 사용하는 setTimeout 함수는 어떻게 동작할까요?\n\n누구나 “start”, “end”가 먼저 콘솔에 노출되고 1초 후 “1 seconds after”가 보인다고 생각하실 겁니다. 하지만 1초를 기다리는 동안 브라우저가 멈추는 현상은 없죠.\n\n여기에서 `JavaScript Runtime`의 역할과 `Event Loop`의 개념이 나오게 됩니다.\n\n![](/assets/blog/javascript-node.js-know-use/2.png)\n\n위에서 사용했던 그림을 다시 보면, 브라우저(**JavaScript Runtime**)는 **JavaScript Engine** 외에도 많은 것들을 제공합니다. setTimout과 같은 다양한 Web APIs의 기능들을 `Multi Thread` 환경에서 처리하며, 그 후에 실행할 콜백함수들을 관리하죠.\n\n**JavaScript Runtime**에서 제공하는 함수들은 대부분 `Non-Blocking`하며 `비동기적`으로 제공됩니다. `비동기적`이라는 말은 `Blocking`/`Non-Blocking`과는 다르며 \u003cu\u003e프로세스의 수행 순서\u003c/u\u003e 보장에 대한 개념으로, 코드가 위에서 아래의 흐름이 지켜지는지에 따라 정해집니다.\n\nsetTimeout 함수의 예제는 수행 순서가 위에서 아래로 일정하지 않으니 `비동기적`이라고 할 수 있습니다.\n\n![](/assets/blog/javascript-node.js-know-use/5.gif)\n\n실행되는 과정을 좀 더 자세히 보면, setTimeout 함수는 **브라우저**에서 제공하므로 JavaScript 코드가 처리되는 **Call Stack**과는 별개로 다른 영역에서 처리되며, 그 후 실행할 작업을 **Callback Queue**에 쌓게 됩니다.\n\n이때 `Event Loop`는 **Call Stack**이 비어있다면 **Callback Queue**의 작업을 가져와 실행할 수 있게 해줍니다.\n\n## 그렇다면 Node.js의 동작 원리는?\n\nJavaScript 코드가 브라우저에서 동작되는 원리를 먼저 설명한 이유는, Node.js에서 동작되는 원리와 세부적인 단계는 다르지만 개념적으론 같기 때문입니다.\n\n그럼 어떤 부분에서 차이가 있을까요?\n\n![](/assets/blog/javascript-node.js-know-use/5.png)\n\n브라우저에서 제공되는 Web APIs의 기능들 대신 시스템 디스크나 네트워크와 상호작용하는 I/O 작업들을 `Non-Blocking`하며 `비동기적`으로 제공합니다. (그렇지 않은 함수들도 있습니다.)\n\n그렇기 때문에 다른 서버와 통신하거나, 데이터베이스에 접근하고, 파일에 접근하는 등의 I/O 작업을 JavaScript Engine 밖에서 수행하며 **Process**가 `Blocking` 되지 않도록 합니다.\n\n이는 Node.js가 **Single Thread** 기반의 `Non-Blocking I/O` 모델이라고 불리는 이유입니다.\n\n![](/assets/blog/javascript-node.js-know-use/6.png)\n\n또 다른 점으로는 브라우저보다 더 많은 FIFO 대기열(Queue)을 가지며, Event Loop가 각 단계를 순회하며 작업을 수행합니다.\n\n## 결론\n\n위에서 보여드린 브라우저나 Node.js의 구조는 이해를 돕기 위해 많은 것들을 생략하여 간단하게 노출한 것들입니다.\n\n전달하고자 했던 내용은 전반적인 JavaScript 코드의 흐름과 동작 원리이며, JavaScript를 잘 사용하기 위해서는 **Single Thread** 로 동작하는 **JavaScript Engine**의 **Call Stack**에 지연되는 작업을 최소화하여 **process**가 `Blocking` 되지 않도록 = `Event Loop` 가 멈추지 않도록 해야 합니다.\n","coverImage":"/assets/blog/javascript-node.js-know-use/cover.jpeg","excerpt":"JavaScript / Node.js의 동작 원리를 통해 코드의 흐름이 어떤 방식으로 진행되며, Single Thread, Event Loop, Non-Blocking I/O에 대해 알고 확장성 있는 애플리케이션을 만들기 위해 어떤 부분을 조심해야 하는지 알아봅시다.","reference":[{"exposed":"어쨌든 이벤트 루프는 무엇입니까? | Philip Roberts | JSConf EU","url":"https://www.youtube.com/watch?v=8aGhZQkoFbQ"},{"exposed":"Don't Block the Event Loop (or the Worker Pool)","url":"https://nodejs.org/en/docs/guides/dont-block-the-event-loop/"},{"exposed":"Overview of Blocking vs Non-Blocking","url":"https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/"},{"exposed":"[10분 테코톡] 유세지의 Node.js","url":"https://www.youtube.com/watch?v=A04zlpL1Uw4"},{"exposed":"Don't block the event loop! 매끄러운 경험을 위한 JavaScript 비동기 처리","url":"https://engineering.linecorp.com/ko/blog/dont-block-the-event-loop/"},{"exposed":"Node.js, lots of ways to block your event-loop (and how to avoid it)","url":"https://medium.com/voodoo-engineering/node-js-lots-of-ways-to-block-your-event-loop-and-how-to-avoid-it-b41f41deecf5"},{"exposed":"How JavaScript works: an overview of the engine, the runtime, and the call stack","url":"https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf"},{"exposed":"Node.js는 어떻게 동작하는가","url":"https://yceffort.kr/2020/10/how-node-js-works"},{"exposed":"Javascript 동작원리 (Single thread, Event loop, Asynchronous)","url":"https://medium.com/@vdongbin/javascript-작동원리-single-thread-event-loop-asynchronous-e47e07b24d1c"},{"exposed":"자바스크립트와 이벤트 루프","url":"https://meetup.nhncloud.com/posts/89"}],"tag":["JavaScript","Node.js"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"javascript-node.js-know-use"},"buildId":"pM8n3hZBguJ-JIdhB0EWY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>