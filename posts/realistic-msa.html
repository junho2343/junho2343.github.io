<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="/favicon/social_preview.jpeg"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="google-site-verification" content="UvtxWDaEi6g_ZkTZOmiWKdYOwB5WgIEEdhSJ6DWnoVc"/><title>현실적인 MSA에 대해 | 문준호</title><meta property="og:image" content="/assets/blog/realistic-msa/1.webp"/><meta name="description" content="MSA에 대해 드는 저의 주관적인 생각을 정리한 내용입니다. MSA 도입을 고민 중인 분들에게 도움이 되었으면 합니다."/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/4ee6c8f74811bd26.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee6c8f74811bd26.css" data-n-g=""/><link rel="preload" href="/_next/static/css/91ec727b30312911.css" as="style"/><link rel="stylesheet" href="/_next/static/css/91ec727b30312911.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-82e23718ef308082.js" defer=""></script><script src="/_next/static/chunks/framework-d51ece3d757c7ed2.js" defer=""></script><script src="/_next/static/chunks/main-f8c0f8da2c690304.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7bce9e33c0a2bac4.js" defer=""></script><script src="/_next/static/chunks/2015-e9026f5023475b2b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4fe8af076c6c50c5.js" defer=""></script><script src="/_next/static/j-4zDW8wbECNYs43umnSs/_buildManifest.js" defer=""></script><script src="/_next/static/j-4zDW8wbECNYs43umnSs/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex justify-center w-full border-b border-b-[#d8e0e7] pt-10 pb-2 sticky top-0 z-10 bg-white"><div class="w-full max-w-4xl min-w-[320px] undefined px-4"><a class="pr-4 font-[400]" href="/about">About</a><a class="pr-4 font-[400]" href="/">Posts</a></div></div><div class="min-h-screen flex items-center flex-col relative"><div class="w-full max-w-4xl min-w-[320px] undefined px-4"><main><div class=""><div class="max-w-2xl pt-14 mx-auto relative"><article class="mb-32"><div class="pb-3"><h1>현실적인 MSA에 대해</h1><div class="mt-1 mb-6"><span class="bg-slate-100 p-1.5 mr-1 rounded text-xs font-normal">2023-01-06</span><span class="bg-slate-100 p-1.5 mr-1 mt-1 rounded text-xs font-normal 
      undefined 
      undefined
      
      ">#<!-- -->아키텍처</span><span class="bg-slate-100 p-1.5 mr-1 mt-1 rounded text-xs font-normal 
      undefined 
      undefined
      
      ">#<!-- -->MSA</span></div><div class="aspect-video sm:mx-0"><img src="/assets/blog/realistic-msa/1.webp" alt="" class="w-full h-full object-cover"/></div></div><div class="markdown-styles_markdown-body__gSZH5"><blockquote>
<p>MSA에 대해 드는 저의 주관적인 생각을 정리한 내용입니다. MSA 도입을 고민 중인 분들에게 도움이 되었으면 합니다.</p>
</blockquote>
<h2 id="msa를-도입하는-이유">MSA를 도입하는 이유</h2>
<p>아마 많은 회사에서 서비스의 성장에 따라 트래픽을 감당하기 어려워지거나, 서비스 확장에 어려움을 느끼는 등 다양한 이유로 MSA 도입을 고민하고 계실 거라고 생각합니다. 정리하자면 아래와 같은 이유가 있을 것 같네요.</p>
<ul>
<li>서비스 성장에 따른 폭발적인 트래픽</li>
<li>부분적인 scale-out 어려움</li>
<li>하나의 기술 스택에 종속되어 각 기능에 적합한 기술을 사용하기 어려움</li>
<li>부분 장애가 전체 장애로 전파될 위험성</li>
<li>서비스가 크고 복잡해짐에 따른 개선/확장의 어려움</li>
</ul>
<h2 id="장점만-있지는-않다">장점만 있지는 않다</h2>
<p>모든 기술에는 트레이드오프(trade-off)가 있듯, 마이크로서비스로의 전환은 장점만큼 고려해야 할 점이 꽤 있습니다.</p>
<ul>
<li>IPC(Inter-Process Communication)
<ul>
<li>네트워크상 분리된 서비스 간의 통신 고려</li>
</ul>
</li>
<li>분산 트랜잭션
<ul>
<li>분리된 서비스 간 DB 트랜잭션 처리 고려(🤬)</li>
</ul>
</li>
<li>운영(인력)
<ul>
<li>서비스가 분리된 만큼 관리 포인트 증가</li>
</ul>
</li>
</ul>
<p>현실적으로 빅테크기업이 아닌 스타트업이나 규모가 작은 팀에서 모든 기능을 세세히 분리하여 관리/운영하는 건 생각보다 쉽지 않습니다. 또한 <u>오버엔지니어링</u>이 발생하지 않도록 정말 마이크로서비스로 전환해야만 문제해결이 가능한지도 고려해 봐야 합니다.</p>
<ul>
<li>서버 트래픽이 문제라면
<ul>
<li><code>scale-up</code>을 통해 단일 서버의 성능을 올리기</li>
<li><code>scale-out</code> 과 <code>로드밸런싱</code>을 통해 여러 대의 서버로 트래픽을 분산하기</li>
</ul>
</li>
<li>DB 트래픽이 문제라면
<ul>
<li>읽기 작업이 문제라면
<ul>
<li>이미 조회한 데이터를 <code>Cache</code>를 통해 재사용</li>
<li><code>Replication</code> 을 통해 <code>Read/Write</code> DB 분리</li>
</ul>
</li>
<li>쓰기 작업이 문제라면
<ul>
<li><code>Vertical Partitioning</code>을 통한 동일한 DB 내 테이블을 분할</li>
<li><code>Horizontal Partitioning(Sharding)</code>을 통한 DB 서버를 분할</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>이러한 부분들을 모두 생각한 후 마이크로서비스로의 전환을 마음먹었다면, <code>비즈니스의 요구사항</code>/<code>서비스 독립성 우선 확보</code> 등을 비교하여 우선순위를 둔 후 한 서비스씩 점진적으로 전환하길 추천해 드립니다.</p>
<p>이는 <u>스트랭글러 패턴(Strangler Pattern)</u> 이라고도 불리며, 더디게 진행될 수 있지만 안정성과 우선순위가 시급한 서비스를 먼저 전환할 수 있어 효율적입니다.</p>
<h2 id="분리된-서비스-간-통신-방법">분리된 서비스 간 통신 방법</h2>
<p>전환할 서비스를 선택했다면 분리된 서비스 간의 통신 방법(IPC)에 대해 고민을 해봐야 합니다. 크게 응답을 기다리는 동기적인 방법과 응답을 기다리지 않는 비동기적인 방법이 있는데요. (예시는 한가지씩만 들었습니다.)</p>
<ul>
<li>동기방식
<ul>
<li>HTTP 통신</li>
</ul>
</li>
<li>비동기방식
<ul>
<li>메시징 시스템</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog/realistic-msa/2.png" alt=""/><span></span></p>
<p>데이터 조회 같은 읽기 위주의 작업은 보통 응답을 바로 줘야 하기에 <code>동기적</code>인 방법을 사용하며 캐싱 등 다양한 방법을 통해 대처할 수 있습니다. 반면 특정 액션을 수행해야 하는 쓰기 위주의 작업은 서비스에 따라 처리시간이 오래 걸릴 수 있으며, 트래픽이 몰릴 경우 <code>동기적</code>인 방법으로는 한계가 있습니다. 그래서 사용자에게 응답을 기다리지 않고 작업 요청이 성공됐는지만 알려준 후 실제 작업은 따로 처리될 수 있도록 <code>비동기적</code>인 방법을 많이 사용합니다.</p>
<p>쇼핑몰로 예를 들자면, 상품 데이터를 조회하여 노출해줄 때는 지연이 없도록 <code>동기적</code>으로 응답받은 후 바로 보여줍니다. 하지만 상품을 주문하는 작업의 경우 배송까지 시간이 걸리기에 성공적으로 주문이 접수됐는지만 알려준 후 실제 처리는 따로 진행될 수 있도록 <code>비동기적</code>인 방법을 사용할 수 있겠죠.</p>
<p>추가적인 예로 단순한 회원가입조차 트래픽을 감당할 수 없어 고민 중이라면, 해당 작업의 주 행위를 <code>동기적</code>으로 처리한 후 다른 부가적인 작업을 <code>비동기적</code>으로 처리하는 방법도 있습니다. 회원가입이라는 주 행위만을 처리한 후 신규회원 쿠폰 발급, 가입 메시지 발송 등의 부가적인 작업을 나중에 처리하여 <u>비관심사들의 분리</u>를 진행할 수 있습니다.</p>
<h2 id="메시징-시스템-이용">메시징 시스템 이용</h2>
<p>MSA는 분리된 서비스 간 결합을 낮게 유지하는 게 핵심이며, 앞서 말했던 마이크로서비스 간 통신방법에서 영향을 많이 받습니다. 변경 사항이 발생할 때 대상 서비스만 이해하고 처리가 될 수 있도록 <u>명확한 경계</u>를 가지도록 말이죠.</p>
<p>서비스가 분리되면 코드상의 요청은 <code>동기적</code>인 HTTP 통신으로 변경됩니다. 이는 대상 서비스를 알고 호출해야 하기 때문에 서비스는 분리되었지만 결합이 느슨해지지는 않았습니다.</p>
<p><img src="/assets/blog/realistic-msa/3.png" alt=""/><span></span></p>
<p>이러한 마이크로서비스 간 결합을 느슨하게 가져가는 방법으로는 메시징 시스템을 이용한 <code>비동기 요청</code>이 있습니다. 하지만 이 방법도 항상 느슨한 결합을 보장하지는 않으며, 이 부분에 대해서는 이벤트 기반 아키텍처와 함께 설명을 이어가겠습니다.</p>
<h2 id="이벤트-기반-아키텍처와-느슨한-결합">이벤트 기반 아키텍처와 느슨한 결합</h2>
<p><img src="/assets/blog/realistic-msa/4.webp" alt=""/><span></span></p>
<p>MSA와 함께 언급되는 <code>EDA</code>(Event Driven Architecture)는 이러한 느슨한 결합을 가져갈 수 있도록 도와줍니다. EDA는 마이크로서비스 간 통신을 이벤트 중심으로 처리하는 설계 패턴으로 생산자/게시자가 이벤트를 생성하고 소비자/구독자는 이벤트를 소비하여 다양한 작업을 수행합니다.</p>
<p>이벤트 기반 아키텍처가 느슨한 결합을 가져갈 수 있는 이유는 생산자는 소비자에 대해 아무것도 몰라도 이벤트를 전달할 수 있기 때문입니다.</p>
<p>회원가입 작업 중 신규회원 쿠폰 발급을 하기 위해 다른 서비스에 메시지를 보내야 한다고 가정하겠습니다. 이때 신규회원 쿠폰 발급이라는 <u>목적을 담은 메시지</u>를 전달하게 된다면 생산자는 소비자와 의존관계가 남아 있으므로 결합이 느슨해졌다고 볼 수 없습니다.</p>
<p>반면 발생한 <u>회원가입 자체(이벤트)</u>를 메시지로 전달한다면 생산자와 소비자는 서로에 대해 알지 못하며 <u>명확한 경계</u>를 가지고 두 서비스는 느슨한 결합을 가지게 됩니다.</p>
<h2 id="결론">결론</h2>
<p>전달하고자 했던 내용은 마이크로서비스로의 전환이 현재 인력/기술에서 오버엔지니어링인지 확인한 후 점진적으로 전환을 이어갔으면 하는 내용입니다. 또한 MSA의 핵심은 결합을 최대한 느슨하게 가져가며 명확한 경계를 가져야 장점을 잘 발휘할 수 있는 것 같습니다.</p></div><div class="mt-20"><div class="markdown-styles_markdown-body__gSZH5"><h2>Reference</h2><ul><li>회원시스템 이벤트기반 아키텍처 구축하기<ul><li><a href="https://techblog.woowahan.com/7835/" target="_blank">https://techblog.woowahan.com/7835/</a></li></ul></li><li>이모티콘 서비스는 왜 MSA를 선택했나?<ul><li><a href="https://tech.kakao.com/2021/09/14/msa/" target="_blank">https://tech.kakao.com/2021/09/14/msa/</a></li></ul></li><li>오늘의집 MSA Phase 1. 전환전략<ul><li><a href="https://www.bucketplace.com/post/2021-11-19-오늘의집-msa-여정-part-1-시작/" target="_blank">https://www.bucketplace.com/post/2021-11-19-오늘의집-msa-여정-part-1-시작/</a></li></ul></li><li>LG CNS 기술블로그 DX Lounge에서 최신 IT 소식을 만나보세요!<ul><li><a href="https://www.lgcns.com/blog/cns-tech/36171/" target="_blank">https://www.lgcns.com/blog/cns-tech/36171/</a></li></ul></li><li>오버 엔지니어링과 기술 부채<ul><li><a href="https://seokjun.kim/over-engineering-vs-techincal-debt/" target="_blank">https://seokjun.kim/over-engineering-vs-techincal-debt/</a></li></ul></li><li>DDD와 MSA 기반으로 좋은 서비스 개발하기<ul><li><a href="https://helloworld.kurly.com/blog/ddd-msa-service-development/" target="_blank">https://helloworld.kurly.com/blog/ddd-msa-service-development/</a></li></ul></li><li>[MSA] Asynchronous Backing Service<ul><li><a href="https://waspro.tistory.com/435" target="_blank">https://waspro.tistory.com/435</a></li></ul></li><li>Competing Consumers pattern<ul><li><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers" target="_blank">https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers</a></li></ul></li><li>How Event-Driven Architectures Benefit from Stream Processing<ul><li><a href="https://pandio.com/event-streams-queues/" target="_blank">https://pandio.com/event-streams-queues/</a></li></ul></li><li>What is event-driven architecture (EDA)?<ul><li><a href="https://aws.amazon.com/what-is/eda/" target="_blank">https://aws.amazon.com/what-is/eda/</a></li></ul></li><li>Event-driven architecture<ul><li><a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank">https://en.wikipedia.org/wiki/Event-driven_architecture</a></li></ul></li><li>Event-Driven Microservice Architecture<ul><li><a href="https://medium.com/trendyol-tech/event-driven-microservice-architecture-91f80ceaa21e" target="_blank">https://medium.com/trendyol-tech/event-driven-microservice-architecture-91f80ceaa21e</a></li></ul></li><li>Event-driven architectures<ul><li><a href="https://cloud.google.com/eventarc/docs/event-driven-architectures" target="_blank">https://cloud.google.com/eventarc/docs/event-driven-architectures</a></li></ul></li><li>Event-driven architecture with Pub/Sub<ul><li><a href="https://cloud.google.com/solutions/event-driven-architecture-pubsub" target="_blank">https://cloud.google.com/solutions/event-driven-architecture-pubsub</a></li></ul></li></ul></div></div></article><div></div><div class="absolute right-0 top-3"><a href="https://hits.seeyoufarm.com"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fjunho2343.github.io%2Fhit-counter%2Frealistic-msa&amp;count_bg=%230366D6&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=&amp;edge_flat=false"/></a></div></div></div></main></div></div><div class="w-full h-20 mt-10 flex justify-center border-t border-t-[#d8e0e7] bg-[#f6f9fc] "><div class="w-full max-w-4xl min-w-[320px] flex items-center px-4"><span class="text-[#8898a9] font-[300]">© Moon Junho. 2022</span><a href="https://github.com/junho2343" target="_blank"><img src="/assets/icon_github_logo.svg" alt="" class="pl-4"/></a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"현실적인 MSA에 대해","date":"2023-01-06","slug":"realistic-msa","content":"\n\u003e MSA에 대해 드는 저의 주관적인 생각을 정리한 내용입니다. MSA 도입을 고민 중인 분들에게 도움이 되었으면 합니다.\n\n## MSA를 도입하는 이유\n\n아마 많은 회사에서 서비스의 성장에 따라 트래픽을 감당하기 어려워지거나, 서비스 확장에 어려움을 느끼는 등 다양한 이유로 MSA 도입을 고민하고 계실 거라고 생각합니다. 정리하자면 아래와 같은 이유가 있을 것 같네요.\n\n- 서비스 성장에 따른 폭발적인 트래픽\n- 부분적인 scale-out 어려움\n- 하나의 기술 스택에 종속되어 각 기능에 적합한 기술을 사용하기 어려움\n- 부분 장애가 전체 장애로 전파될 위험성\n- 서비스가 크고 복잡해짐에 따른 개선/확장의 어려움\n\n## 장점만 있지는 않다\n\n모든 기술에는 트레이드오프(trade-off)가 있듯, 마이크로서비스로의 전환은 장점만큼 고려해야 할 점이 꽤 있습니다.\n\n- IPC(Inter-Process Communication)\n  - 네트워크상 분리된 서비스 간의 통신 고려\n- 분산 트랜잭션\n  - 분리된 서비스 간 DB 트랜잭션 처리 고려(🤬)\n- 운영(인력)\n  - 서비스가 분리된 만큼 관리 포인트 증가\n\n현실적으로 빅테크기업이 아닌 스타트업이나 규모가 작은 팀에서 모든 기능을 세세히 분리하여 관리/운영하는 건 생각보다 쉽지 않습니다. 또한 \u003cu\u003e오버엔지니어링\u003c/u\u003e이 발생하지 않도록 정말 마이크로서비스로 전환해야만 문제해결이 가능한지도 고려해 봐야 합니다.\n\n- 서버 트래픽이 문제라면\n  - `scale-up`을 통해 단일 서버의 성능을 올리기\n  - `scale-out` 과 `로드밸런싱`을 통해 여러 대의 서버로 트래픽을 분산하기\n- DB 트래픽이 문제라면\n  - 읽기 작업이 문제라면\n    - 이미 조회한 데이터를 `Cache`를 통해 재사용\n    - `Replication` 을 통해 `Read/Write` DB 분리\n  - 쓰기 작업이 문제라면\n    - `Vertical Partitioning`을 통한 동일한 DB 내 테이블을 분할\n    - `Horizontal Partitioning(Sharding)`을 통한 DB 서버를 분할\n\n이러한 부분들을 모두 생각한 후 마이크로서비스로의 전환을 마음먹었다면, `비즈니스의 요구사항`/`서비스 독립성 우선 확보` 등을 비교하여 우선순위를 둔 후 한 서비스씩 점진적으로 전환하길 추천해 드립니다.\n\n이는 \u003cu\u003e스트랭글러 패턴(Strangler Pattern)\u003c/u\u003e 이라고도 불리며, 더디게 진행될 수 있지만 안정성과 우선순위가 시급한 서비스를 먼저 전환할 수 있어 효율적입니다.\n\n## 분리된 서비스 간 통신 방법\n\n전환할 서비스를 선택했다면 분리된 서비스 간의 통신 방법(IPC)에 대해 고민을 해봐야 합니다. 크게 응답을 기다리는 동기적인 방법과 응답을 기다리지 않는 비동기적인 방법이 있는데요. (예시는 한가지씩만 들었습니다.)\n\n- 동기방식\n  - HTTP 통신\n- 비동기방식\n  - 메시징 시스템\n\n![](/assets/blog/realistic-msa/2.png)\n\n데이터 조회 같은 읽기 위주의 작업은 보통 응답을 바로 줘야 하기에 `동기적`인 방법을 사용하며 캐싱 등 다양한 방법을 통해 대처할 수 있습니다. 반면 특정 액션을 수행해야 하는 쓰기 위주의 작업은 서비스에 따라 처리시간이 오래 걸릴 수 있으며, 트래픽이 몰릴 경우 `동기적`인 방법으로는 한계가 있습니다. 그래서 사용자에게 응답을 기다리지 않고 작업 요청이 성공됐는지만 알려준 후 실제 작업은 따로 처리될 수 있도록 `비동기적`인 방법을 많이 사용합니다.\n\n쇼핑몰로 예를 들자면, 상품 데이터를 조회하여 노출해줄 때는 지연이 없도록 `동기적`으로 응답받은 후 바로 보여줍니다. 하지만 상품을 주문하는 작업의 경우 배송까지 시간이 걸리기에 성공적으로 주문이 접수됐는지만 알려준 후 실제 처리는 따로 진행될 수 있도록 `비동기적`인 방법을 사용할 수 있겠죠.\n\n추가적인 예로 단순한 회원가입조차 트래픽을 감당할 수 없어 고민 중이라면, 해당 작업의 주 행위를 `동기적`으로 처리한 후 다른 부가적인 작업을 `비동기적`으로 처리하는 방법도 있습니다. 회원가입이라는 주 행위만을 처리한 후 신규회원 쿠폰 발급, 가입 메시지 발송 등의 부가적인 작업을 나중에 처리하여 \u003cu\u003e비관심사들의 분리\u003c/u\u003e를 진행할 수 있습니다.\n\n## 메시징 시스템 이용\n\nMSA는 분리된 서비스 간 결합을 낮게 유지하는 게 핵심이며, 앞서 말했던 마이크로서비스 간 통신방법에서 영향을 많이 받습니다. 변경 사항이 발생할 때 대상 서비스만 이해하고 처리가 될 수 있도록 \u003cu\u003e명확한 경계\u003c/u\u003e를 가지도록 말이죠.\n\n서비스가 분리되면 코드상의 요청은 `동기적`인 HTTP 통신으로 변경됩니다. 이는 대상 서비스를 알고 호출해야 하기 때문에 서비스는 분리되었지만 결합이 느슨해지지는 않았습니다.\n\n![](/assets/blog/realistic-msa/3.png)\n\n이러한 마이크로서비스 간 결합을 느슨하게 가져가는 방법으로는 메시징 시스템을 이용한 `비동기 요청`이 있습니다. 하지만 이 방법도 항상 느슨한 결합을 보장하지는 않으며, 이 부분에 대해서는 이벤트 기반 아키텍처와 함께 설명을 이어가겠습니다.\n\n## 이벤트 기반 아키텍처와 느슨한 결합\n\n![](/assets/blog/realistic-msa/4.webp)\n\nMSA와 함께 언급되는 `EDA`(Event Driven Architecture)는 이러한 느슨한 결합을 가져갈 수 있도록 도와줍니다. EDA는 마이크로서비스 간 통신을 이벤트 중심으로 처리하는 설계 패턴으로 생산자/게시자가 이벤트를 생성하고 소비자/구독자는 이벤트를 소비하여 다양한 작업을 수행합니다.\n\n이벤트 기반 아키텍처가 느슨한 결합을 가져갈 수 있는 이유는 생산자는 소비자에 대해 아무것도 몰라도 이벤트를 전달할 수 있기 때문입니다.\n\n회원가입 작업 중 신규회원 쿠폰 발급을 하기 위해 다른 서비스에 메시지를 보내야 한다고 가정하겠습니다. 이때 신규회원 쿠폰 발급이라는 \u003cu\u003e목적을 담은 메시지\u003c/u\u003e를 전달하게 된다면 생산자는 소비자와 의존관계가 남아 있으므로 결합이 느슨해졌다고 볼 수 없습니다.\n\n반면 발생한 \u003cu\u003e회원가입 자체(이벤트)\u003c/u\u003e를 메시지로 전달한다면 생산자와 소비자는 서로에 대해 알지 못하며 \u003cu\u003e명확한 경계\u003c/u\u003e를 가지고 두 서비스는 느슨한 결합을 가지게 됩니다.\n\n## 결론\n\n전달하고자 했던 내용은 마이크로서비스로의 전환이 현재 인력/기술에서 오버엔지니어링인지 확인한 후 점진적으로 전환을 이어갔으면 하는 내용입니다. 또한 MSA의 핵심은 결합을 최대한 느슨하게 가져가며 명확한 경계를 가져야 장점을 잘 발휘할 수 있는 것 같습니다.\n","coverImage":"/assets/blog/realistic-msa/1.webp","excerpt":"MSA에 대해 드는 저의 주관적인 생각을 정리한 내용입니다. MSA 도입을 고민 중인 분들에게 도움이 되었으면 합니다.","reference":[{"exposed":"회원시스템 이벤트기반 아키텍처 구축하기","url":"https://techblog.woowahan.com/7835/"},{"exposed":"이모티콘 서비스는 왜 MSA를 선택했나?","url":"https://tech.kakao.com/2021/09/14/msa/"},{"exposed":"오늘의집 MSA Phase 1. 전환전략","url":"https://www.bucketplace.com/post/2021-11-19-오늘의집-msa-여정-part-1-시작/"},{"exposed":"LG CNS 기술블로그 DX Lounge에서 최신 IT 소식을 만나보세요!","url":"https://www.lgcns.com/blog/cns-tech/36171/"},{"exposed":"오버 엔지니어링과 기술 부채","url":"https://seokjun.kim/over-engineering-vs-techincal-debt/"},{"exposed":"DDD와 MSA 기반으로 좋은 서비스 개발하기","url":"https://helloworld.kurly.com/blog/ddd-msa-service-development/"},{"exposed":"[MSA] Asynchronous Backing Service","url":"https://waspro.tistory.com/435"},{"exposed":"Competing Consumers pattern","url":"https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers"},{"exposed":"How Event-Driven Architectures Benefit from Stream Processing","url":"https://pandio.com/event-streams-queues/"},{"exposed":"What is event-driven architecture (EDA)?","url":"https://aws.amazon.com/what-is/eda/"},{"exposed":"Event-driven architecture","url":"https://en.wikipedia.org/wiki/Event-driven_architecture"},{"exposed":"Event-Driven Microservice Architecture","url":"https://medium.com/trendyol-tech/event-driven-microservice-architecture-91f80ceaa21e"},{"exposed":"Event-driven architectures","url":"https://cloud.google.com/eventarc/docs/event-driven-architectures"},{"exposed":"Event-driven architecture with Pub/Sub","url":"https://cloud.google.com/solutions/event-driven-architecture-pubsub"}],"tags":["아키텍처","MSA"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"realistic-msa"},"buildId":"j-4zDW8wbECNYs43umnSs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>