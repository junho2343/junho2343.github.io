<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="/favicon/social_preview.jpeg"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="google-site-verification" content="UvtxWDaEi6g_ZkTZOmiWKdYOwB5WgIEEdhSJ6DWnoVc"/><title>객체지향 JavaScript 이론 | 문준호</title><meta property="og:image" content="/assets/blog/oop-javascript/cover.png"/><meta name="description" content="객체지향 프로그래밍의 이론과 궁극적인 목표에 대해 정리한 내용입니다."/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/c17d92c06b0e655f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c17d92c06b0e655f.css" data-n-g=""/><link rel="preload" href="/_next/static/css/5f4ec60f2cf4afa1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5f4ec60f2cf4afa1.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-a7decae7732b8a4d.js" defer=""></script><script src="/_next/static/chunks/framework-d51ece3d757c7ed2.js" defer=""></script><script src="/_next/static/chunks/main-6d1b4f24429df6fa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8b1e3442f7d45e31.js" defer=""></script><script src="/_next/static/chunks/2015-e9026f5023475b2b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4ba26e82a2298801.js" defer=""></script><script src="/_next/static/5DI_p0qoEOLD-WAmPrFWo/_buildManifest.js" defer=""></script><script src="/_next/static/5DI_p0qoEOLD-WAmPrFWo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex justify-center w-full border-b border-b-[#d8e0e7] pt-10 pb-2 sticky top-0 z-10 bg-white"><div class="w-full max-w-4xl min-w-[320px] undefined px-4"><a class="pr-4 font-[400]" href="/about">About</a><a class="pr-4 font-[400]" href="/">Posts</a><a class="pr-4 font-[400]" href="/gallery">Gallery</a></div></div><div class="min-h-screen flex items-center flex-col relative"><div class="w-full max-w-4xl min-w-[320px] undefined px-4"><div class="max-w-2xl pt-14 mx-auto relative"><article class="mb-32"><div class="pb-3"><h1>객체지향 JavaScript 이론</h1><div class="mt-1 mb-6"><span class="bg-slate-100 p-1.5 mr-1 rounded text-xs font-normal">2023-02-20</span><span class="bg-slate-100 p-1.5 mr-1 mt-1 rounded text-xs font-normal 
      undefined 
      undefined
      
      ">#<!-- -->JavaScript</span><span class="bg-slate-100 p-1.5 mr-1 mt-1 rounded text-xs font-normal 
      undefined 
      undefined
      
      ">#<!-- -->OOP</span><span class="bg-slate-100 p-1.5 mr-1 mt-1 rounded text-xs font-normal 
      undefined 
      undefined
      
      ">#<!-- -->코드스피츠</span></div><div class="aspect-video sm:mx-0"><img src="https://cdn.jsdelivr.net/gh/junho2343/junho2343.github.io/public/assets/blog/oop-javascript/cover.png" alt="" class="w-full h-full object-cover"/></div></div><div class="markdown-styles_markdown-body__gSZH5"><blockquote>
<p>객체지향 프로그래밍의 이론과 궁극적인 목표에 대해 정리한 내용이며, 아래 강의영상을 보고 정리한 내용입니다.</p>
<p><a href="https://www.youtube.com/watch?v=E9NZ0YEZrYU">https://www.youtube.com/watch?v=E9NZ0YEZrYU</a></p>
</blockquote>
<h2 id="value-context-vs-identifier-context">Value Context VS Identifier Context</h2>
<p>FP(함수형 프로그래밍), OOP(객체지향 프로그래밍)를 구분하는 중요한 개념은 프로그램을 개발할 때 Value Context/Identifier Context 중 어떤 관점으로 개발하냐에 따라 정해진다.</p>
<ul>
<li>Value Context
<ul>
<li>메모리 주소와 관계없이 들어있는 값을 봄</li>
<li>함수지향</li>
</ul>
</li>
<li>Identifier Context
<ul>
<li>값이 아닌 메모리 주소를 봄</li>
<li>객체지향</li>
</ul>
</li>
</ul>
<p>이 두 가지를 혼용하는 순간 혼란이 가중되어 버그가 발생할 수 있다. 되도록 하나의 관점(Context)으로 개발하는 걸 권장한다.</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span></code><code class="language-javascript" style="white-space:pre">const a = { a: 3, b: 5 };
const b = { a: 3, b: 5 };

// Identifier Context
console.log(a === b); // false

// Value Context
console.log(JSON.stringify(a) === JSON.stringify(b)); // true</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<p>객체지향의 가장 기본은 메소드의 인자, 리턴하는 값 등 전부 다 객체(Identifier)만 사용해야 하며, 값(value)을 사용할 수 있는 건 <code>생성자</code>가 유일하다.</p>
<h3 id="value-특징">Value 특징</h3>
<!-- -->
<ul>
<li>끝없는 복사본
<ul>
<li>참조하지 않는다.</li>
<li>값을 할당하거나, 함수 인자로 넘길 때 언제나 복사본을 만든다.
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span></code><code class="language-javascript" style="white-space:pre">  let a = 1;
  let b = a;

  a = 2;

  console.log(a); // 2
  console.log(b); // 1</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
</li>
</ul>
</li>
<li>상태 변화에 안전?
<ul>
<li>뭘 하든 복사본이 만들어지니 상태가 변할 수 없다.</li>
<li>상태가 관리되어 안전한 게 아니라, 계속 불변하는 값을 만들어서 안전해 보일 뿐이다.
<ul>
<li><code>3 + 1 = 4</code>  ⇒ 3과 1은 그대로 있고 4가 만들어진다.</li>
<li>이걸 관리하기 위해 함수형 프로그래밍 등장. 미리 정해진 함수의 연산을 사용.</li>
</ul>
</li>
</ul>
</li>
<li>연산을 기반으로 전개
<ul>
<li>공식이 자주 바뀌거나, 복잡한 도메인의 연산을 표현하기는 어렵다.</li>
<li>수식이 정해져 있고 간단하다면 추천
<ul>
<li>넷플릭스 어울림 ⇒ 동영상을 스트리밍하는 게 다니까</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="identifier-특징">Identifier 특징</h3>
<ul>
<li>하나의 원본
<ul>
<li>하나의 객체를 가지고 속성을 바꾸면서 사용 ⇒ 상태가 일관성이 없음</li>
</ul>
</li>
<li>상태 변화를 내부에서 책임짐
<ul>
<li>바뀐 속성에 대한 조건들을 내부에서 제어해야 함 ⇒ 어려움</li>
</ul>
</li>
<li>메세지를 기반으로 로직을 전개
<ul>
<li>구현한 데까지 만들고 나머지는 실패 유도를 할 수 있음</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 객체지향의 가장 중요한 점은 값(value)을 사용하지 않는다.</p>
</blockquote>
<h2 id="다형성polymorphism">다형성(Polymorphism)</h2>
<p><code>다형성</code>(Polymorphism) = <code>대체가능성</code>(substitution) + <code>내적일관성</code>(internal identity)</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span></code><code class="language-javascript" style="white-space:pre">const Worker = class {
  run() {
    console.log(&quot;working&quot;);
  }
  print() {
    this.run();
  }
};

// Overriding
const HardWorker = class extends Worker {
  run() {
    console.log(&quot;HardWorking&quot;);
  }
};

const worker = new HardWorker();

console.log(worker instanceof Worker); // true

worker.print(); // HardWorking =&gt; HardWorker의 run()</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<h3 id="대체가능성substitution">대체가능성(substitution)</h3>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span></code><code class="language-javascript" style="white-space:pre">console.log(worker instanceof Worker); // true</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<ul>
<li>확장된 객체는 원본으로 대체 가능</li>
<li>확장된 class는 대상 class를 대체할 수 있다</li>
<li>자식 class는 부모 class를 대체할 수 있다</li>
<li>HardWorker의 부분집합은 Worker</li>
</ul>
<h3 id="내적일관성internal-identity">내적일관성(internal identity)</h3>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span></code><code class="language-javascript" style="white-space:pre">worker.print(); // HardWorking =&gt; HardWorker의 run()</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<ul>
<li>생성 시점의 타입이 내부에 일관성 있게 참조됨</li>
<li>어떠한 경우에도 태어났을 때의 원본 class를 유지하려는 속성</li>
<li>worker는 HardWorker class이므로 this.run() ⇒ HardWorker의 run()을 의미</li>
</ul>
<blockquote>
<p>💡 객체지향언어란?</p>
<p>다형성(Polymorphism)[<code>대체가능성</code> + <code>내적일관성</code>]이 언어 차원에서 지원되는 것을 의미한다. 이를 구현하는 방식은 언어마다 굉장히 다르며, JavaScript에서는 prototype을 통해 지원한다.</p>
</blockquote>
<h2 id="객체의-본질object-essentials">객체의 본질(Object Essentials)</h2>
<p>객체지향언어를 쓴다고 객체지향 프로그래밍을 하는 건 아니다. 객체지향 프로그래밍을 위한 조건들을 살펴보자.</p>
<p><code>객체의 본질</code>(Object Essentials) = <code>기능의 캡슐화</code>(Encapsulation of functionality) + <code>상태 관리 책임</code>(Maintenance of state)</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span></code><code class="language-javascript" style="white-space:pre">const EssentialObject = class {
  #name = &quot;&quot;;
  #screen = null;

  constructor(name) {
    this.#name = name;
  }

  camouflage(name) {
    this.#screen = (Math.random() * 10).toString(16).replace(&quot;.&quot;, &quot;&quot;);
  }

  get name() {
    return this.#screen || this.#name;
  }
};</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<h3 id="기능의-캡슐화encapsulation-of-functionality">기능의 캡슐화(Encapsulation of functionality)</h3>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span></code><code class="language-javascript" style="white-space:pre">get name() {
  return this.#screen || this.#name;
}</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<ul>
<li>외부에 기능(메소드)을 감춘다.
<ul>
<li>ATM을 생각하면, 단순한 인터페이스를 보여주고 복잡한 작업들은 노출하지 않는다.</li>
<li><code>setAge</code> method는 캡슐화가 아니다. 나이를 <strong>어디에</strong>, <strong>왜</strong> 사용하는지 생각하고 <code>setChild</code>, <code>setAdult</code>와 같은 method로 직접적인 노출을 하지 않고 기능의 캡슐화가 가능하다.</li>
</ul>
</li>
</ul>
<h3 id="상태-관리-책임maintenance-of-state">상태 관리 책임(Maintenance of state)</h3>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span></code><code class="language-javascript" style="white-space:pre">#name = &quot;&quot;;
#screen = null;

...

camouflage(name) {
this.#screen = (Math.random() \* 10).toString(16).replace(&quot;.&quot;, &quot;&quot;);
}
</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<ul>
<li>외부에 상태(데이터)를 감춘다. ⇒ hide state
<ul>
<li>객체의 속성이 노출되는 순간 값으로 사용된다. 이후 Value Context로 움직이기 때문에 객체지향은 무너진다.</li>
</ul>
</li>
<li>상태에 대한 관리는 내가 직접 한다.
<ul>
<li><code>setAge</code> method는 외부에서 나이를 조절할 수 있으니 이에 위배된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 객체지향 프로그래밍이란?</p>
<p>구현한 모든 객체가 <code>상태 관리 책임</code>(Maintenance of state) + <code>기능의 캡슐화</code>(Encapsulation of functionality)를 만족하도록 해야 한다.</p>
</blockquote>
<h3 id="변화의-격리isloation-of-change">변화의 격리(Isloation of change)</h3>
<ul>
<li>모든 프로그램은 계속해서 변하며, 변화를 막을 순 없다.</li>
<li>모든 프로그래밍 언어의 궁극적인 목표는 변화에 대한 격리다.
<ul>
<li>A를 수정했다고 B에서 문제가 발생하면 안 됨.</li>
</ul>
</li>
<li>객체지향에서 <code>상태 관리 책임</code>+ <code>기능의 캡슐화</code>를 객체의 본질로 보는 이유는, 변화의 여파를 막고 격리벽을 세울 수 있는 유일한 수단이기 때문이다.</li>
</ul>
<h2 id="객체지향의-알려진-기본-설계-요령">객체지향의 알려진 기본 설계 요령</h2>
<p>SOLID 원칙</p>
<h2 id="srp--단일책임single-responsibility-원칙">SRP - 단일책임(Single Responsibility) 원칙</h2>
<ul>
<li>코드를 수정하는 원인은 오직 하나뿐이다.
<ul>
<li>하나의 기능만 가지며 하나의 책임을 수행하는 데 집중한다.</li>
</ul>
</li>
<li>격리 수준이 높다면 촘촘한 단위테스트는 필요 없다.</li>
</ul>
<h3 id="ocp--개방폐쇄open-closed-원칙">OCP - 개방폐쇄(Open Closed) 원칙</h3>
<ul>
<li>Open: <code>implements</code>, <code>extends</code>를 할 수 있게 만들어라.</li>
<li>Closed: 수정이 필요할 경우 기존의 class를 건드는 게 아니라<code>implements</code>, <code>extends</code>를 통해 또다른 class를 만들어 해결한다.</li>
<li>변할 부분과 변하지 않을 부분을 명확히 구분하고, 문제에 대한 공통점을 인식해서 추상화에 성공해야한다.</li>
</ul>
<h3 id="lsp--업캐스팅-안전liskov-substitusion-원칙">LSP - 업캐스팅 안전(Liskov Substitusion) 원칙</h3>
<ul>
<li>추상층의 정의가 너무 구체적이면 구상층의 구현에서 모순이 발생한다.</li>
<li>자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.
<ul>
<li>다형성의 대체 가능성?</li>
</ul>
</li>
</ul>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span></code><code class="language-typescript" style="white-space:pre">abstract class Biology {
  breathe() {}
  moveToLeg() {}
}

class Human extends Biology {}
class Ostrich extends Biology {}
class Ameba extends Biology {}
class Eagle extends Biology {}
class Whale extends Biology {}</code></div><span class="absolute right-2 top-1 text-white">typescript</span></pre>
<ul>
<li>추상층 - 생물
<ul>
<li>숨을쉰다, 다리로 이동한다.</li>
</ul>
</li>
<li>구상층
<ul>
<li>사람 ok</li>
<li>타조 ok</li>
<li>아메바 no</li>
<li>독수리 no</li>
<li>고래 no</li>
</ul>
</li>
<li>아메바 독수리 고래는 생물이지만 다리로 이동할 수 없으므로 <code>upcasting</code>을 할 수 없다.</li>
</ul>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span></code><code class="language-typescript" style="white-space:pre">abstract class Biology {
  breathe() {}
}

interface MoveToLegAble {
  moveToLeg: () =&gt; void;
}

class Human extends Biology implements MoveToLegAble {
  moveToLeg() {}
}
class Ostrich extends Biology implements MoveToLegAble {
  moveToLeg() {}
}
class Ameba extends Biology {}
class Eagle extends Biology {}
class Whale extends Biology {}</code></div><span class="absolute right-2 top-1 text-white">typescript</span></pre>
<h3 id="isp--인터페이스-분리interface-segregation-원칙">ISP - 인터페이스 분리(Interface Segregation) 원칙</h3>
<ul>
<li>앞에서 예제로 사용한 코드도 LSP를 해결하기 위해 ISP를 사용했다고 할 수 있다.
<ul>
<li>예제를 조금 더 추가해보자.</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog/oop-javascript/1.png" alt="ISP 반영 전"/><span>ISP 반영 전</span></p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span></code><code class="language-typescript" style="white-space:pre">abstract class Biology {
  breathe() {}
  moveToLeg() {}
  fly() {}
}

class Human extends Biology {}
class Ostrich extends Biology {}
class Ameba extends Biology {}
class Eagle extends Biology {}
class Whale extends Biology {}</code></div><span class="absolute right-2 top-1 text-white">typescript</span></pre>
<ul>
<li>숨을쉰다
<ul>
<li>모두 ok</li>
</ul>
</li>
<li>다리로 이동한다
<ul>
<li>사람, 타조</li>
</ul>
</li>
<li>난다
<ul>
<li>독수리</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog/oop-javascript/2.png" alt="ISP 반영 후"/><span>ISP 반영 후</span></p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span></code><code class="language-typescript" style="white-space:pre">abstract class Biology {
  breathe() {}
}

abstract class MoveToLegAbleBiology extends Biology {
  moveToLeg() {}
}
abstract class flyAbleBiology extends Biology {
  fly() {}
}

class Human extends MoveToLegAbleBiology {}
class Ostrich extends MoveToLegAbleBiology {}
class Ameba extends Biology {}
class Eagle extends flyAbleBiology {}
class Whale extends Biology {}</code></div><span class="absolute right-2 top-1 text-white">typescript</span></pre>
<p>혹은 아래와 같이 사용할 수 있을 것 같습니다.</p>
<p><img src="/assets/blog/oop-javascript/3.png" alt="ISP 반영 후"/><span>ISP 반영 후</span></p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span></code><code class="language-typescript" style="white-space:pre">abstract class Biology {
  breathe() {}
}

interface MoveToLegAble {
  moveToLeg: () =&gt; void;
}
interface flyAble {
  fly: () =&gt; void;
}

class Human extends Biology implements MoveToLegAble {
  moveToLeg() {}
}
class Ostrich extends Biology implements MoveToLegAble {
  moveToLeg() {}
}
class Ameba extends Biology {}
class Eagle extends Biology implements flyAble {
  fly() {}
}
class Whale extends Biology {}</code></div><span class="absolute right-2 top-1 text-white">typescript</span></pre>
<h3 id="dip--다운캐스팅금지dependency-inversion-원칙">DIP - 다운캐스팅금지(Dependency Inversion) 원칙</h3>
<ul>
<li>의존성 역전의 법칙.
<ul>
<li>의존성은 언제나 부모 쪽으로 흘러야 한다.</li>
</ul>
</li>
<li>위 원칙들을 모두 지켜야 다운캐스팅이 일어나지 않는다
<ul>
<li>다운캐스팅이 있으면 객체지향이 무너진다.</li>
</ul>
</li>
</ul>
<h3 id="그-외">그 외</h3>
<ul>
<li>DI(Dependency Injection) - 의존성 주입
<ul>
<li>IOC(Inversion of control) - 제어역전의 일부. 구현체 중 하나</li>
</ul>
</li>
<li>DRY(Don&#x27;t Repeat Yourself) - 중복방지</li>
<li>Hollyworld Principle - 의존성 부패방지</li>
<li>Law of demeter - 최소지식</li>
</ul>
<blockquote>
<p>위 내용은 가이드를 위한 기준. 이후 영상에서 상세하게 배워보자.</p>
</blockquote>
<h2 id="message">Message</h2>
<ul>
<li>메세지를 기반으로 로직을 전개.</li>
<li>내가 해결할 수 없는 건 다른 녀석에게 Message를 보낸다.</li>
</ul>
<h3 id="srp단일책임원칙를-준수하는-객체망이-문제를-해결">SRP(단일책임원칙)를 준수하는 객체망이 문제를 해결</h3>
<ul>
<li>설계는 언제나 상황/조직을 보고 유연하게 처리한다.
<ul>
<li>어느 정도 수준까지 쪼갤지.</li>
</ul>
</li>
<li>단일 책임 원칙을 준수하는 객체에게 책임 이상의 업무를 부여하면?
<ul>
<li>만능 객체가 되려 한다.</li>
<li>다른 객체에게 의뢰한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>다른 객체에게 의뢰하는 것 = 다른 객체에게 메세지를 보내는 것</p>
</blockquote>
<ul>
<li>메세지 - 의뢰할 내용</li>
<li>오퍼레이션 - 메시지를 수신할 객체가 제공하는 서비스
<ul>
<li>객체를 사용하기 위해 외부에 노출되는 서비스 메뉴판 느낌</li>
<li>오퍼레이터가 런타임에 어떤 메소드랑 매핑될지 결정하는 걸 <code>동적바인딩</code>이라고 한다.</li>
</ul>
</li>
<li>메소드 - 오퍼레이션과 연결될 실제 처리기</li>
</ul>
<blockquote>
<ul>
<li>추상클래스를 상속받거나 인터페이스를 상속받는 이유
<ul>
<li>오퍼레이션과 메서드를 분리해서 런타임에 원하는 것을 사용하기 위함 (OCP)</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="의존성dependency">의존성(Dependency)</h2>
<ul>
<li>가장 중요한 격리의 문제</li>
<li>다른 사람의 문제로 내가 영향을 받는 것</li>
</ul>
<blockquote>
<p>다른 객체를 알고 의뢰를 해야 하지만, 나에게 영향은 없어야 한다. (모순적이기에 어렵다.)</p>
<p>디자인(설계)에서 각각 의존성을 적절히 가질 수 있도록 적당한 <code>균형점</code>을 찾아야 한다.</p>
</blockquote>
<h3 id="의존성의-종류">의존성의 종류</h3>
<ol>
<li>객체 생명 주기 전체에 걸친 의존성
<ul>
<li>상속(extends)</li>
<li>연관(association)</li>
</ul>
</li>
<li>각 오퍼레이션 실행 시 임시적인 의존성
<ul>
<li>의존(dependency)</li>
</ul>
</li>
</ol>
<blockquote>
<p>의존성이 높다면?</p>
<ul>
<li>수정 여파 규모 증가</li>
<li>수정하기 어려운 구조 생성</li>
<li>순환 의존성
<ul>
<li>A가 의존한 B가 의존한 C가 의존한 D에서 문제 발생</li>
<li>타이틀을 바꿨는데 게시판이 먹통</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>객체지향을 배우는 이유는 격리구간을 세우고 의존성을 관리하기 위해서다. 변화에 대해 격리를 하기 위해.</p>
</blockquote>
<h2 id="의존성-역전-dependency-inversion">의존성 역전 (Dependency Inversion)</h2>
<ul>
<li>다운캐스팅(DIP) 금지</li>
<li>Polymorphism(추상인터페이스) 사용</li>
</ul>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span></code><code class="language-javascript" style="white-space:pre">const Worker = class {
  run() {
    console.log(&quot;working&quot;);
  }
  print() {
    this.run();
  }
};

const HardWorker = class extends Worker {
  run() {
    console.log(&quot;HardWorking&quot;);
  }
};

const worker = new HardWorker();

const Manager = class {
  #workers;
  constructor(...workers) {
    if (workers.every((w) =&gt; w instanceof Worker)) this.#workers = workers;
    else throw &quot;invalid workers&quot;;
  }
  doWork() {
    this.#wokers.forEach((w) =&gt; w.run());
  }
};

const manager = new Manager(new Worker(), new HardWorker());
manager.doWork(); // working, hardworking</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<ul>
<li>개방폐쇄원칙(OCP) 준수
<ul>
<li>Worker로 부터 확장된 객체를 더 만들 수 있음 ⇒ Open</li>
<li>확장할 때마다 코드를 수정할 필요 없음 ⇒ Closed
<ul>
<li>확장된 객체(HardWorker)가 아닌 추상화된 객체(Worker)를 사용</li>
</ul>
</li>
</ul>
</li>
<li>개방폐쇄원칙(OCP)을 준수하면 의존성 역전 원칙(DIP)은 자연스럽게 달성
<ul>
<li>OCP와 DIP는 깊은 관계</li>
<li>OCP가 안되면 DIP가 될 리 없다.</li>
</ul>
</li>
</ul>
<h2 id="제어역전-inversion-of-control">제어역전 (Inversion of Control)</h2>
<ul>
<li>객체지향에서 도달해야 할 궁극적인 목표.</li>
<li>나머지 원칙들을 모두 준수해야 달성할 수 있음.</li>
</ul>
<h3 id="개념">개념</h3>
<ol>
<li>Control = flow control(흐름 제어)</li>
<li>광의에서 흐름 제어 = 프로그램 실행 통제</li>
<li>동기 흐름제어, 비동기 흐름제어 등</li>
</ol>
<h3 id="문제점">문제점</h3>
<ul>
<li>흐름 제어는 상태와 결합하여 진행됨</li>
<li>상태 통제와 흐름 제어 = 알고리즘</li>
<li>변화에 취약하고 구현하기도 어려움
<ul>
<li>함수 1개가 120줄이면.. 경우의 수가 수백가지.. 예측이 힘들다.</li>
<li>예측도 힘든데 유지보수는 더 어려움.</li>
</ul>
</li>
</ul>
<h3 id="대안">대안</h3>
<ul>
<li>제어를 추상화하고</li>
<li>개별 제어의 차이점만 외부에서 주입받는다.
<ul>
<li>아래 예제를 가지고 자세히 봐보자.</li>
</ul>
</li>
</ul>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span><span class="react-syntax-highlighter-line-number">46
</span><span class="react-syntax-highlighter-line-number">47
</span><span class="react-syntax-highlighter-line-number">48
</span><span class="react-syntax-highlighter-line-number">49
</span><span class="react-syntax-highlighter-line-number">50
</span><span class="react-syntax-highlighter-line-number">51
</span><span class="react-syntax-highlighter-line-number">52
</span><span class="react-syntax-highlighter-line-number">53
</span><span class="react-syntax-highlighter-line-number">54
</span><span class="react-syntax-highlighter-line-number">55
</span><span class="react-syntax-highlighter-line-number">56
</span><span class="react-syntax-highlighter-line-number">57
</span><span class="react-syntax-highlighter-line-number">58
</span><span class="react-syntax-highlighter-line-number">59
</span><span class="react-syntax-highlighter-line-number">60
</span><span class="react-syntax-highlighter-line-number">61
</span><span class="react-syntax-highlighter-line-number">62
</span><span class="react-syntax-highlighter-line-number">63
</span><span class="react-syntax-highlighter-line-number">64
</span><span class="react-syntax-highlighter-line-number">65
</span><span class="react-syntax-highlighter-line-number">66
</span></code><code class="language-javascript" style="white-space:pre">const Renderer = class {
  #view = null;
  #base = null;

  constructor(baseElement) {
    this.#base = baseElement;
  }

  set view(v) {
    if (v instanceof View) this.#view = v;
    else throw `invalid view: ${v}`;
  }

  render(data) {
    const base = this.#base,
      view = this.#view;

    if (!base || !view) throw &quot;no base or no view&quot;;

    let target = base.firstElementChild;

    do base.removeChild(target);
    while ((target = target.nextElementSibling));

    base.appendChild(view.getElement(data));
    view.initAni();
    view.startAni();
  }
};

const View = class {
  getElement(data) {
    throw `override!`;
  }
  initAni() {
    throw &quot;override!&quot;;
  }
  startAni() {
    throw &quot;override!&quot;;
  }
};

const renderer = new Renderer(document.body);
renderer.view = new (class extends View {
  #el;
  getElement(data) {
    this.#el = document.createElement(&quot;div&quot;);
    this.#el.innerHTML = `&lt;h2&gt;${data.title}&lt;/h2&gt;&lt;p&gt;${data.description}&lt;/p&gt;`;
    this.#el.style.cssText = `width:100%;background:${data.background}`;
    return this.#el;
  }
  initAni() {
    const style = this.#el.style;
    style.marginLeft = &quot;100%&quot;;
    style.transition = &quot;0.3s&quot;;
  }
  startAni() {
    requestAnimationFrame(() =&gt; (this.#el.style.marginLeft = 0));
  }
})();

renderer.render({
  title: &quot;title test&quot;,
  description: &quot;contents.........&quot;,
  background: &quot;#ffffaa&quot;,
});</code></div><span class="absolute right-2 top-1 text-white">javascript</span></pre>
<ul>
<li>renderer에서만 <code>제어</code>를 처리함.
<ul>
<li>얘만 고치면 됨.</li>
</ul>
</li>
<li>제어 외의 view는 주입(공급)받아 사용.</li>
</ul>
<blockquote>
<ul>
<li><code>Framework</code>
<ul>
<li>제어 역전을 사용.</li>
<li>일부의 기능들을 정의 ⇒ 그걸 모아서 실행(제어) 시켜줌</li>
</ul>
</li>
<li><code>Library</code>
<ul>
<li>제어하지 않음.</li>
<li>기능을 가져다 사용</li>
</ul>
</li>
</ul>
</blockquote></div><div class="mt-20"><div class="markdown-styles_markdown-body__gSZH5"><h2>Reference</h2><ul><li>코드스피츠 86 객체지향 자바스크립트 - 1회차<ul><li><a href="https://www.youtube.com/watch?v=E9NZ0YEZrYU" target="_blank">https://www.youtube.com/watch?v=E9NZ0YEZrYU</a></li></ul></li></ul></div></div></article><div></div><div class="absolute right-0 top-3"><a href="https://hits.seeyoufarm.com"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fjunho2343.github.io%2Fhit-counter%2Foop-javascript&amp;count_bg=%230366D6&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=&amp;edge_flat=false"/></a></div></div></div></div><div class="w-full h-20 mt-10 flex justify-center border-t border-t-[#d8e0e7] bg-[#f6f9fc] "><div class="w-full max-w-4xl min-w-[320px] flex items-center px-4"><span class="text-[#8898a9] font-[300]">© Moon Junho. 2022</span><a href="https://github.com/junho2343" target="_blank"><img src="/assets/icon_github_logo.svg" alt="" class="pl-4"/></a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"객체지향 JavaScript 이론","date":"2023-02-20","slug":"oop-javascript","content":"\n\u003e 객체지향 프로그래밍의 이론과 궁극적인 목표에 대해 정리한 내용이며, 아래 강의영상을 보고 정리한 내용입니다.\n\u003e\n\u003e [https://www.youtube.com/watch?v=E9NZ0YEZrYU](https://www.youtube.com/watch?v=E9NZ0YEZrYU)\n\n## Value Context VS Identifier Context\n\nFP(함수형 프로그래밍), OOP(객체지향 프로그래밍)를 구분하는 중요한 개념은 프로그램을 개발할 때 Value Context/Identifier Context 중 어떤 관점으로 개발하냐에 따라 정해진다.\n\n- Value Context\n  - 메모리 주소와 관계없이 들어있는 값을 봄\n  - 함수지향\n- Identifier Context\n  - 값이 아닌 메모리 주소를 봄\n  - 객체지향\n\n이 두 가지를 혼용하는 순간 혼란이 가중되어 버그가 발생할 수 있다. 되도록 하나의 관점(Context)으로 개발하는 걸 권장한다.\n\n```javascript\nconst a = { a: 3, b: 5 };\nconst b = { a: 3, b: 5 };\n\n// Identifier Context\nconsole.log(a === b); // false\n\n// Value Context\nconsole.log(JSON.stringify(a) === JSON.stringify(b)); // true\n```\n\n객체지향의 가장 기본은 메소드의 인자, 리턴하는 값 등 전부 다 객체(Identifier)만 사용해야 하며, 값(value)을 사용할 수 있는 건 `생성자`가 유일하다.\n\n### Value 특징\n\n\u003c!-- prettier-ignore --\u003e\n- 끝없는 복사본\n  - 참조하지 않는다.\n  - 값을 할당하거나, 함수 인자로 넘길 때 언제나 복사본을 만든다.\n    ```javascript\n      let a = 1;\n      let b = a;\n\n      a = 2;\n\n      console.log(a); // 2\n      console.log(b); // 1\n    ```\n- 상태 변화에 안전?\n  - 뭘 하든 복사본이 만들어지니 상태가 변할 수 없다.\n  - 상태가 관리되어 안전한 게 아니라, 계속 불변하는 값을 만들어서 안전해 보일 뿐이다.\n    - `3 + 1 = 4`  ⇒ 3과 1은 그대로 있고 4가 만들어진다.\n    - 이걸 관리하기 위해 함수형 프로그래밍 등장. 미리 정해진 함수의 연산을 사용.\n- 연산을 기반으로 전개\n  - 공식이 자주 바뀌거나, 복잡한 도메인의 연산을 표현하기는 어렵다.\n  - 수식이 정해져 있고 간단하다면 추천\n    - 넷플릭스 어울림 ⇒ 동영상을 스트리밍하는 게 다니까\n\n### Identifier 특징\n\n- 하나의 원본\n  - 하나의 객체를 가지고 속성을 바꾸면서 사용 ⇒ 상태가 일관성이 없음\n- 상태 변화를 내부에서 책임짐\n  - 바뀐 속성에 대한 조건들을 내부에서 제어해야 함 ⇒ 어려움\n- 메세지를 기반으로 로직을 전개\n  - 구현한 데까지 만들고 나머지는 실패 유도를 할 수 있음\n\n\u003caside\u003e\n\n💡 객체지향의 가장 중요한 점은 값(value)을 사용하지 않는다.\n\n\u003c/aside\u003e\n\n## 다형성(Polymorphism)\n\n`다형성`(Polymorphism) = `대체가능성`(substitution) + `내적일관성`(internal identity)\n\n```javascript\nconst Worker = class {\n  run() {\n    console.log(\"working\");\n  }\n  print() {\n    this.run();\n  }\n};\n\n// Overriding\nconst HardWorker = class extends Worker {\n  run() {\n    console.log(\"HardWorking\");\n  }\n};\n\nconst worker = new HardWorker();\n\nconsole.log(worker instanceof Worker); // true\n\nworker.print(); // HardWorking =\u003e HardWorker의 run()\n```\n\n### 대체가능성(substitution)\n\n```javascript\nconsole.log(worker instanceof Worker); // true\n```\n\n- 확장된 객체는 원본으로 대체 가능\n- 확장된 class는 대상 class를 대체할 수 있다\n- 자식 class는 부모 class를 대체할 수 있다\n- HardWorker의 부분집합은 Worker\n\n### 내적일관성(internal identity)\n\n```javascript\nworker.print(); // HardWorking =\u003e HardWorker의 run()\n```\n\n- 생성 시점의 타입이 내부에 일관성 있게 참조됨\n- 어떠한 경우에도 태어났을 때의 원본 class를 유지하려는 속성\n- worker는 HardWorker class이므로 this.run() ⇒ HardWorker의 run()을 의미\n\n\u003caside\u003e\n\n💡 객체지향언어란?\n\n다형성(Polymorphism)[`대체가능성` + `내적일관성`]이 언어 차원에서 지원되는 것을 의미한다. 이를 구현하는 방식은 언어마다 굉장히 다르며, JavaScript에서는 prototype을 통해 지원한다.\n\n\u003c/aside\u003e\n\n## 객체의 본질(Object Essentials)\n\n객체지향언어를 쓴다고 객체지향 프로그래밍을 하는 건 아니다. 객체지향 프로그래밍을 위한 조건들을 살펴보자.\n\n`객체의 본질`(Object Essentials) = `기능의 캡슐화`(Encapsulation of functionality) + `상태 관리 책임`(Maintenance of state)\n\n```javascript\nconst EssentialObject = class {\n  #name = \"\";\n  #screen = null;\n\n  constructor(name) {\n    this.#name = name;\n  }\n\n  camouflage(name) {\n    this.#screen = (Math.random() * 10).toString(16).replace(\".\", \"\");\n  }\n\n  get name() {\n    return this.#screen || this.#name;\n  }\n};\n```\n\n### 기능의 캡슐화(Encapsulation of functionality)\n\n```javascript\nget name() {\n  return this.#screen || this.#name;\n}\n```\n\n- 외부에 기능(메소드)을 감춘다.\n  - ATM을 생각하면, 단순한 인터페이스를 보여주고 복잡한 작업들은 노출하지 않는다.\n  - `setAge` method는 캡슐화가 아니다. 나이를 **어디에**, **왜** 사용하는지 생각하고 `setChild`, `setAdult`와 같은 method로 직접적인 노출을 하지 않고 기능의 캡슐화가 가능하다.\n\n### 상태 관리 책임(Maintenance of state)\n\n```javascript\n#name = \"\";\n#screen = null;\n\n...\n\ncamouflage(name) {\nthis.#screen = (Math.random() \\* 10).toString(16).replace(\".\", \"\");\n}\n\n```\n\n- 외부에 상태(데이터)를 감춘다. ⇒ hide state\n  - 객체의 속성이 노출되는 순간 값으로 사용된다. 이후 Value Context로 움직이기 때문에 객체지향은 무너진다.\n- 상태에 대한 관리는 내가 직접 한다.\n  - `setAge` method는 외부에서 나이를 조절할 수 있으니 이에 위배된다.\n\n\u003caside\u003e\n\n💡 객체지향 프로그래밍이란?\n\n구현한 모든 객체가 `상태 관리 책임`(Maintenance of state) + `기능의 캡슐화`(Encapsulation of functionality)를 만족하도록 해야 한다.\n\n\u003c/aside\u003e\n\n### 변화의 격리(Isloation of change)\n\n- 모든 프로그램은 계속해서 변하며, 변화를 막을 순 없다.\n- 모든 프로그래밍 언어의 궁극적인 목표는 변화에 대한 격리다.\n  - A를 수정했다고 B에서 문제가 발생하면 안 됨.\n- 객체지향에서 `상태 관리 책임`+ `기능의 캡슐화`를 객체의 본질로 보는 이유는, 변화의 여파를 막고 격리벽을 세울 수 있는 유일한 수단이기 때문이다.\n\n## 객체지향의 알려진 기본 설계 요령\n\nSOLID 원칙\n\n## SRP - 단일책임(Single Responsibility) 원칙\n\n- 코드를 수정하는 원인은 오직 하나뿐이다.\n  - 하나의 기능만 가지며 하나의 책임을 수행하는 데 집중한다.\n- 격리 수준이 높다면 촘촘한 단위테스트는 필요 없다.\n\n### OCP - 개방폐쇄(Open Closed) 원칙\n\n- Open: `implements`, `extends`를 할 수 있게 만들어라.\n- Closed: 수정이 필요할 경우 기존의 class를 건드는 게 아니라`implements`, `extends`를 통해 또다른 class를 만들어 해결한다.\n- 변할 부분과 변하지 않을 부분을 명확히 구분하고, 문제에 대한 공통점을 인식해서 추상화에 성공해야한다.\n\n### LSP - 업캐스팅 안전(Liskov Substitusion) 원칙\n\n- 추상층의 정의가 너무 구체적이면 구상층의 구현에서 모순이 발생한다.\n- 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.\n  - 다형성의 대체 가능성?\n\n```typescript\nabstract class Biology {\n  breathe() {}\n  moveToLeg() {}\n}\n\nclass Human extends Biology {}\nclass Ostrich extends Biology {}\nclass Ameba extends Biology {}\nclass Eagle extends Biology {}\nclass Whale extends Biology {}\n```\n\n- 추상층 - 생물\n  - 숨을쉰다, 다리로 이동한다.\n- 구상층\n  - 사람 ok\n  - 타조 ok\n  - 아메바 no\n  - 독수리 no\n  - 고래 no\n- 아메바 독수리 고래는 생물이지만 다리로 이동할 수 없으므로 `upcasting`을 할 수 없다.\n\n```typescript\nabstract class Biology {\n  breathe() {}\n}\n\ninterface MoveToLegAble {\n  moveToLeg: () =\u003e void;\n}\n\nclass Human extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ostrich extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ameba extends Biology {}\nclass Eagle extends Biology {}\nclass Whale extends Biology {}\n```\n\n### ISP - 인터페이스 분리(Interface Segregation) 원칙\n\n- 앞에서 예제로 사용한 코드도 LSP를 해결하기 위해 ISP를 사용했다고 할 수 있다.\n  - 예제를 조금 더 추가해보자.\n\n![ISP 반영 전](/assets/blog/oop-javascript/1.png)\n\n```typescript\nabstract class Biology {\n  breathe() {}\n  moveToLeg() {}\n  fly() {}\n}\n\nclass Human extends Biology {}\nclass Ostrich extends Biology {}\nclass Ameba extends Biology {}\nclass Eagle extends Biology {}\nclass Whale extends Biology {}\n```\n\n- 숨을쉰다\n  - 모두 ok\n- 다리로 이동한다\n  - 사람, 타조\n- 난다\n  - 독수리\n\n![ISP 반영 후](/assets/blog/oop-javascript/2.png)\n\n```typescript\nabstract class Biology {\n  breathe() {}\n}\n\nabstract class MoveToLegAbleBiology extends Biology {\n  moveToLeg() {}\n}\nabstract class flyAbleBiology extends Biology {\n  fly() {}\n}\n\nclass Human extends MoveToLegAbleBiology {}\nclass Ostrich extends MoveToLegAbleBiology {}\nclass Ameba extends Biology {}\nclass Eagle extends flyAbleBiology {}\nclass Whale extends Biology {}\n```\n\n혹은 아래와 같이 사용할 수 있을 것 같습니다.\n\n![ISP 반영 후](/assets/blog/oop-javascript/3.png)\n\n```typescript\nabstract class Biology {\n  breathe() {}\n}\n\ninterface MoveToLegAble {\n  moveToLeg: () =\u003e void;\n}\ninterface flyAble {\n  fly: () =\u003e void;\n}\n\nclass Human extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ostrich extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ameba extends Biology {}\nclass Eagle extends Biology implements flyAble {\n  fly() {}\n}\nclass Whale extends Biology {}\n```\n\n### DIP - 다운캐스팅금지(Dependency Inversion) 원칙\n\n- 의존성 역전의 법칙.\n  - 의존성은 언제나 부모 쪽으로 흘러야 한다.\n- 위 원칙들을 모두 지켜야 다운캐스팅이 일어나지 않는다\n  - 다운캐스팅이 있으면 객체지향이 무너진다.\n\n### 그 외\n\n- DI(Dependency Injection) - 의존성 주입\n  - IOC(Inversion of control) - 제어역전의 일부. 구현체 중 하나\n- DRY(Don't Repeat Yourself) - 중복방지\n- Hollyworld Principle - 의존성 부패방지\n- Law of demeter - 최소지식\n\n\u003caside\u003e\n\n위 내용은 가이드를 위한 기준. 이후 영상에서 상세하게 배워보자.\n\n\u003c/aside\u003e\n\n## Message\n\n- 메세지를 기반으로 로직을 전개.\n- 내가 해결할 수 없는 건 다른 녀석에게 Message를 보낸다.\n\n### SRP(단일책임원칙)를 준수하는 객체망이 문제를 해결\n\n- 설계는 언제나 상황/조직을 보고 유연하게 처리한다.\n  - 어느 정도 수준까지 쪼갤지.\n- 단일 책임 원칙을 준수하는 객체에게 책임 이상의 업무를 부여하면?\n  - 만능 객체가 되려 한다.\n  - 다른 객체에게 의뢰한다.\n\n\u003e 다른 객체에게 의뢰하는 것 = 다른 객체에게 메세지를 보내는 것\n\n- 메세지 - 의뢰할 내용\n- 오퍼레이션 - 메시지를 수신할 객체가 제공하는 서비스\n  - 객체를 사용하기 위해 외부에 노출되는 서비스 메뉴판 느낌\n  - 오퍼레이터가 런타임에 어떤 메소드랑 매핑될지 결정하는 걸 `동적바인딩`이라고 한다.\n- 메소드 - 오퍼레이션과 연결될 실제 처리기\n\n\u003e - 추상클래스를 상속받거나 인터페이스를 상속받는 이유\n\u003e   - 오퍼레이션과 메서드를 분리해서 런타임에 원하는 것을 사용하기 위함 (OCP)\n\n## 의존성(Dependency)\n\n- 가장 중요한 격리의 문제\n- 다른 사람의 문제로 내가 영향을 받는 것\n\n\u003caside\u003e\n\n다른 객체를 알고 의뢰를 해야 하지만, 나에게 영향은 없어야 한다. (모순적이기에 어렵다.)\n\n디자인(설계)에서 각각 의존성을 적절히 가질 수 있도록 적당한 `균형점`을 찾아야 한다.\n\n\u003c/aside\u003e\n\n### 의존성의 종류\n\n1. 객체 생명 주기 전체에 걸친 의존성\n   - 상속(extends)\n   - 연관(association)\n2. 각 오퍼레이션 실행 시 임시적인 의존성\n   - 의존(dependency)\n\n\u003caside\u003e\n\n의존성이 높다면?\n\n- 수정 여파 규모 증가\n- 수정하기 어려운 구조 생성\n- 순환 의존성\n  - A가 의존한 B가 의존한 C가 의존한 D에서 문제 발생\n  - 타이틀을 바꿨는데 게시판이 먹통\n\n\u003c/aside\u003e\n\n\u003caside\u003e\n\n객체지향을 배우는 이유는 격리구간을 세우고 의존성을 관리하기 위해서다. 변화에 대해 격리를 하기 위해.\n\n\u003c/aside\u003e\n\n## 의존성 역전 (Dependency Inversion)\n\n- 다운캐스팅(DIP) 금지\n- Polymorphism(추상인터페이스) 사용\n\n```javascript\nconst Worker = class {\n  run() {\n    console.log(\"working\");\n  }\n  print() {\n    this.run();\n  }\n};\n\nconst HardWorker = class extends Worker {\n  run() {\n    console.log(\"HardWorking\");\n  }\n};\n\nconst worker = new HardWorker();\n\nconst Manager = class {\n  #workers;\n  constructor(...workers) {\n    if (workers.every((w) =\u003e w instanceof Worker)) this.#workers = workers;\n    else throw \"invalid workers\";\n  }\n  doWork() {\n    this.#wokers.forEach((w) =\u003e w.run());\n  }\n};\n\nconst manager = new Manager(new Worker(), new HardWorker());\nmanager.doWork(); // working, hardworking\n```\n\n- 개방폐쇄원칙(OCP) 준수\n  - Worker로 부터 확장된 객체를 더 만들 수 있음 ⇒ Open\n  - 확장할 때마다 코드를 수정할 필요 없음 ⇒ Closed\n    - 확장된 객체(HardWorker)가 아닌 추상화된 객체(Worker)를 사용\n- 개방폐쇄원칙(OCP)을 준수하면 의존성 역전 원칙(DIP)은 자연스럽게 달성\n  - OCP와 DIP는 깊은 관계\n  - OCP가 안되면 DIP가 될 리 없다.\n\n## 제어역전 (Inversion of Control)\n\n- 객체지향에서 도달해야 할 궁극적인 목표.\n- 나머지 원칙들을 모두 준수해야 달성할 수 있음.\n\n### 개념\n\n1. Control = flow control(흐름 제어)\n2. 광의에서 흐름 제어 = 프로그램 실행 통제\n3. 동기 흐름제어, 비동기 흐름제어 등\n\n### 문제점\n\n- 흐름 제어는 상태와 결합하여 진행됨\n- 상태 통제와 흐름 제어 = 알고리즘\n- 변화에 취약하고 구현하기도 어려움\n  - 함수 1개가 120줄이면.. 경우의 수가 수백가지.. 예측이 힘들다.\n  - 예측도 힘든데 유지보수는 더 어려움.\n\n### 대안\n\n- 제어를 추상화하고\n- 개별 제어의 차이점만 외부에서 주입받는다.\n  - 아래 예제를 가지고 자세히 봐보자.\n\n```javascript\nconst Renderer = class {\n  #view = null;\n  #base = null;\n\n  constructor(baseElement) {\n    this.#base = baseElement;\n  }\n\n  set view(v) {\n    if (v instanceof View) this.#view = v;\n    else throw `invalid view: ${v}`;\n  }\n\n  render(data) {\n    const base = this.#base,\n      view = this.#view;\n\n    if (!base || !view) throw \"no base or no view\";\n\n    let target = base.firstElementChild;\n\n    do base.removeChild(target);\n    while ((target = target.nextElementSibling));\n\n    base.appendChild(view.getElement(data));\n    view.initAni();\n    view.startAni();\n  }\n};\n\nconst View = class {\n  getElement(data) {\n    throw `override!`;\n  }\n  initAni() {\n    throw \"override!\";\n  }\n  startAni() {\n    throw \"override!\";\n  }\n};\n\nconst renderer = new Renderer(document.body);\nrenderer.view = new (class extends View {\n  #el;\n  getElement(data) {\n    this.#el = document.createElement(\"div\");\n    this.#el.innerHTML = `\u003ch2\u003e${data.title}\u003c/h2\u003e\u003cp\u003e${data.description}\u003c/p\u003e`;\n    this.#el.style.cssText = `width:100%;background:${data.background}`;\n    return this.#el;\n  }\n  initAni() {\n    const style = this.#el.style;\n    style.marginLeft = \"100%\";\n    style.transition = \"0.3s\";\n  }\n  startAni() {\n    requestAnimationFrame(() =\u003e (this.#el.style.marginLeft = 0));\n  }\n})();\n\nrenderer.render({\n  title: \"title test\",\n  description: \"contents.........\",\n  background: \"#ffffaa\",\n});\n```\n\n- renderer에서만 `제어`를 처리함.\n  - 얘만 고치면 됨.\n- 제어 외의 view는 주입(공급)받아 사용.\n\n\u003e - `Framework`\n\u003e   - 제어 역전을 사용.\n\u003e   - 일부의 기능들을 정의 ⇒ 그걸 모아서 실행(제어) 시켜줌\n\u003e - `Library`\n\u003e   - 제어하지 않음.\n\u003e   - 기능을 가져다 사용\n","coverImage":"/assets/blog/oop-javascript/cover.png","excerpt":"객체지향 프로그래밍의 이론과 궁극적인 목표에 대해 정리한 내용입니다.","reference":[{"exposed":"코드스피츠 86 객체지향 자바스크립트 - 1회차","url":"https://www.youtube.com/watch?v=E9NZ0YEZrYU"}],"tags":["JavaScript","OOP","코드스피츠"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"oop-javascript"},"buildId":"5DI_p0qoEOLD-WAmPrFWo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>