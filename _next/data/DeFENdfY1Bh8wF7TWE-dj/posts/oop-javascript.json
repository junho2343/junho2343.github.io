{"pageProps":{"post":{"title":"객체지향 JavaScript 이론","date":"2023-02-20","slug":"oop-javascript","content":"\n> 객체지향 프로그래밍의 이론과 궁극적인 목표에 대해 정리한 내용이며, 아래 강의영상을 보고 정리한 내용입니다.\n>\n> [https://www.youtube.com/watch?v=E9NZ0YEZrYU](https://www.youtube.com/watch?v=E9NZ0YEZrYU)\n\n## Value Context VS Identifier Context\n\nFP(함수형 프로그래밍), OOP(객체지향 프로그래밍)를 구분하는 중요한 개념은 프로그램을 개발할 때 Value Context/Identifier Context 중 어떤 관점으로 개발하냐에 따라 정해진다.\n\n- Value Context\n  - 메모리 주소와 관계없이 들어있는 값을 봄\n  - 함수지향\n- Identifier Context\n  - 값이 아닌 메모리 주소를 봄\n  - 객체지향\n\n이 두 가지를 혼용하는 순간 혼란이 가중되어 버그가 발생할 수 있다. 되도록 하나의 관점(Context)으로 개발하는 걸 권장한다.\n\n```javascript\nconst a = { a: 3, b: 5 };\nconst b = { a: 3, b: 5 };\n\n// Identifier Context\nconsole.log(a === b); // false\n\n// Value Context\nconsole.log(JSON.stringify(a) === JSON.stringify(b)); // true\n```\n\n객체지향의 가장 기본은 메소드의 인자, 리턴하는 값 등 전부 다 객체(Identifier)만 사용해야 하며, 값(value)을 사용할 수 있는 건 `생성자`가 유일하다.\n\n### Value 특징\n\n<!-- prettier-ignore -->\n- 끝없는 복사본\n  - 참조하지 않는다.\n  - 값을 할당하거나, 함수 인자로 넘길 때 언제나 복사본을 만든다.\n    ```javascript\n      let a = 1;\n      let b = a;\n\n      a = 2;\n\n      console.log(a); // 2\n      console.log(b); // 1\n    ```\n- 상태 변화에 안전?\n  - 뭘 하든 복사본이 만들어지니 상태가 변할 수 없다.\n  - 상태가 관리되어 안전한 게 아니라, 계속 불변하는 값을 만들어서 안전해 보일 뿐이다.\n    - `3 + 1 = 4`  ⇒ 3과 1은 그대로 있고 4가 만들어진다.\n    - 이걸 관리하기 위해 함수형 프로그래밍 등장. 미리 정해진 함수의 연산을 사용.\n- 연산을 기반으로 전개\n  - 공식이 자주 바뀌거나, 복잡한 도메인의 연산을 표현하기는 어렵다.\n  - 수식이 정해져 있고 간단하다면 추천\n    - 넷플릭스 어울림 ⇒ 동영상을 스트리밍하는 게 다니까\n\n### Identifier 특징\n\n- 하나의 원본\n  - 하나의 객체를 가지고 속성을 바꾸면서 사용 ⇒ 상태가 일관성이 없음\n- 상태 변화를 내부에서 책임짐\n  - 바뀐 속성에 대한 조건들을 내부에서 제어해야 함 ⇒ 어려움\n- 메세지를 기반으로 로직을 전개\n  - 구현한 데까지 만들고 나머지는 실패 유도를 할 수 있음\n\n<aside>\n\n💡 객체지향의 가장 중요한 점은 값(value)을 사용하지 않는다.\n\n</aside>\n\n## 다형성(Polymorphism)\n\n`다형성`(Polymorphism) = `대체가능성`(substitution) + `내적일관성`(internal identity)\n\n```javascript\nconst Worker = class {\n  run() {\n    console.log(\"working\");\n  }\n  print() {\n    this.run();\n  }\n};\n\n// Overriding\nconst HardWorker = class extends Worker {\n  run() {\n    console.log(\"HardWorking\");\n  }\n};\n\nconst worker = new HardWorker();\n\nconsole.log(worker instanceof Worker); // true\n\nworker.print(); // HardWorking => HardWorker의 run()\n```\n\n### 대체가능성(substitution)\n\n```javascript\nconsole.log(worker instanceof Worker); // true\n```\n\n- 확장된 객체는 원본으로 대체 가능\n- 확장된 class는 대상 class를 대체할 수 있다\n- 자식 class는 부모 class를 대체할 수 있다\n- HardWorker의 부분집합은 Worker\n\n### 내적일관성(internal identity)\n\n```javascript\nworker.print(); // HardWorking => HardWorker의 run()\n```\n\n- 생성 시점의 타입이 내부에 일관성 있게 참조됨\n- 어떠한 경우에도 태어났을 때의 원본 class를 유지하려는 속성\n- worker는 HardWorker class이므로 this.run() ⇒ HardWorker의 run()을 의미\n\n<aside>\n\n💡 객체지향언어란?\n\n다형성(Polymorphism)[`대체가능성` + `내적일관성`]이 언어 차원에서 지원되는 것을 의미한다. 이를 구현하는 방식은 언어마다 굉장히 다르며, JavaScript에서는 prototype을 통해 지원한다.\n\n</aside>\n\n## 객체의 본질(Object Essentials)\n\n객체지향언어를 쓴다고 객체지향 프로그래밍을 하는 건 아니다. 객체지향 프로그래밍을 위한 조건들을 살펴보자.\n\n`객체의 본질`(Object Essentials) = `기능의 캡슐화`(Encapsulation of functionality) + `상태 관리 책임`(Maintenance of state)\n\n```javascript\nconst EssentialObject = class {\n  #name = \"\";\n  #screen = null;\n\n  constructor(name) {\n    this.#name = name;\n  }\n\n  camouflage(name) {\n    this.#screen = (Math.random() * 10).toString(16).replace(\".\", \"\");\n  }\n\n  get name() {\n    return this.#screen || this.#name;\n  }\n};\n```\n\n### 기능의 캡슐화(Encapsulation of functionality)\n\n```javascript\nget name() {\n  return this.#screen || this.#name;\n}\n```\n\n- 외부에 기능(메소드)을 감춘다.\n  - ATM을 생각하면, 단순한 인터페이스를 보여주고 복잡한 작업들은 노출하지 않는다.\n  - `setAge` method는 캡슐화가 아니다. 나이를 **어디에**, **왜** 사용하는지 생각하고 `setChild`, `setAdult`와 같은 method로 직접적인 노출을 하지 않고 기능의 캡슐화가 가능하다.\n\n### 상태 관리 책임(Maintenance of state)\n\n```javascript\n#name = \"\";\n#screen = null;\n\n...\n\ncamouflage(name) {\nthis.#screen = (Math.random() \\* 10).toString(16).replace(\".\", \"\");\n}\n\n```\n\n- 외부에 상태(데이터)를 감춘다. ⇒ hide state\n  - 객체의 속성이 노출되는 순간 값으로 사용된다. 이후 Value Context로 움직이기 때문에 객체지향은 무너진다.\n- 상태에 대한 관리는 내가 직접 한다.\n  - `setAge` method는 외부에서 나이를 조절할 수 있으니 이에 위배된다.\n\n<aside>\n\n💡 객체지향 프로그래밍이란?\n\n구현한 모든 객체가 `상태 관리 책임`(Maintenance of state) + `기능의 캡슐화`(Encapsulation of functionality)를 만족하도록 해야 한다.\n\n</aside>\n\n### 변화의 격리(Isloation of change)\n\n- 모든 프로그램은 계속해서 변하며, 변화를 막을 순 없다.\n- 모든 프로그래밍 언어의 궁극적인 목표는 변화에 대한 격리다.\n  - A를 수정했다고 B에서 문제가 발생하면 안 됨.\n- 객체지향에서 `상태 관리 책임`+ `기능의 캡슐화`를 객체의 본질로 보는 이유는, 변화의 여파를 막고 격리벽을 세울 수 있는 유일한 수단이기 때문이다.\n\n## 객체지향의 알려진 기본 설계 요령\n\nSOLID 원칙\n\n## SRP - 단일책임(Single Responsibility) 원칙\n\n- 코드를 수정하는 원인은 오직 하나뿐이다.\n  - 하나의 기능만 가지며 하나의 책임을 수행하는 데 집중한다.\n- 격리 수준이 높다면 촘촘한 단위테스트는 필요 없다.\n\n### OCP - 개방폐쇄(Open Closed) 원칙\n\n- Open: `implements`, `extends`를 할 수 있게 만들어라.\n- Closed: 수정이 필요할 경우 기존의 class를 건드는 게 아니라`implements`, `extends`를 통해 또다른 class를 만들어 해결한다.\n- 변할 부분과 변하지 않을 부분을 명확히 구분하고, 문제에 대한 공통점을 인식해서 추상화에 성공해야한다.\n\n### LSP - 업캐스팅 안전(Liskov Substitusion) 원칙\n\n- 추상층의 정의가 너무 구체적이면 구상층의 구현에서 모순이 발생한다.\n- 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.\n  - 다형성의 대체 가능성?\n\n```typescript\nabstract class Biology {\n  breathe() {}\n  moveToLeg() {}\n}\n\nclass Human extends Biology {}\nclass Ostrich extends Biology {}\nclass Ameba extends Biology {}\nclass Eagle extends Biology {}\nclass Whale extends Biology {}\n```\n\n- 추상층 - 생물\n  - 숨을쉰다, 다리로 이동한다.\n- 구상층\n  - 사람 ok\n  - 타조 ok\n  - 아메바 no\n  - 독수리 no\n  - 고래 no\n- 아메바 독수리 고래는 생물이지만 다리로 이동할 수 없으므로 `upcasting`을 할 수 없다.\n\n```typescript\nabstract class Biology {\n  breathe() {}\n}\n\ninterface MoveToLegAble {\n  moveToLeg: () => void;\n}\n\nclass Human extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ostrich extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ameba extends Biology {}\nclass Eagle extends Biology {}\nclass Whale extends Biology {}\n```\n\n### ISP - 인터페이스 분리(Interface Segregation) 원칙\n\n- 앞에서 예제로 사용한 코드도 LSP를 해결하기 위해 ISP를 사용했다고 할 수 있다.\n  - 예제를 조금 더 추가해보자.\n\n![ISP 반영 전](/assets/blog/oop-javascript/1.png)\n\n```typescript\nabstract class Biology {\n  breathe() {}\n  moveToLeg() {}\n  fly() {}\n}\n\nclass Human extends Biology {}\nclass Ostrich extends Biology {}\nclass Ameba extends Biology {}\nclass Eagle extends Biology {}\nclass Whale extends Biology {}\n```\n\n- 숨을쉰다\n  - 모두 ok\n- 다리로 이동한다\n  - 사람, 타조\n- 난다\n  - 독수리\n\n![ISP 반영 후](/assets/blog/oop-javascript/2.png)\n\n```typescript\nabstract class Biology {\n  breathe() {}\n}\n\nabstract class MoveToLegAbleBiology extends Biology {\n  moveToLeg() {}\n}\nabstract class flyAbleBiology extends Biology {\n  fly() {}\n}\n\nclass Human extends MoveToLegAbleBiology {}\nclass Ostrich extends MoveToLegAbleBiology {}\nclass Ameba extends Biology {}\nclass Eagle extends flyAbleBiology {}\nclass Whale extends Biology {}\n```\n\n혹은 아래와 같이 사용할 수 있을 것 같습니다.\n\n![ISP 반영 후](/assets/blog/oop-javascript/3.png)\n\n```typescript\nabstract class Biology {\n  breathe() {}\n}\n\ninterface MoveToLegAble {\n  moveToLeg: () => void;\n}\ninterface flyAble {\n  fly: () => void;\n}\n\nclass Human extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ostrich extends Biology implements MoveToLegAble {\n  moveToLeg() {}\n}\nclass Ameba extends Biology {}\nclass Eagle extends Biology implements flyAble {\n  fly() {}\n}\nclass Whale extends Biology {}\n```\n\n### DIP - 다운캐스팅금지(Dependency Inversion) 원칙\n\n- 의존성 역전의 법칙.\n  - 의존성은 언제나 부모 쪽으로 흘러야 한다.\n- 위 원칙들을 모두 지켜야 다운캐스팅이 일어나지 않는다\n  - 다운캐스팅이 있으면 객체지향이 무너진다.\n\n### 그 외\n\n- DI(Dependency Injection) - 의존성 주입\n  - IOC(Inversion of control) - 제어역전의 일부. 구현체 중 하나\n- DRY(Don't Repeat Yourself) - 중복방지\n- Hollyworld Principle - 의존성 부패방지\n- Law of demeter - 최소지식\n\n<aside>\n\n위 내용은 가이드를 위한 기준. 이후 영상에서 상세하게 배워보자.\n\n</aside>\n\n## Message\n\n- 메세지를 기반으로 로직을 전개.\n- 내가 해결할 수 없는 건 다른 녀석에게 Message를 보낸다.\n\n### SRP(단일책임원칙)를 준수하는 객체망이 문제를 해결\n\n- 설계는 언제나 상황/조직을 보고 유연하게 처리한다.\n  - 어느 정도 수준까지 쪼갤지.\n- 단일 책임 원칙을 준수하는 객체에게 책임 이상의 업무를 부여하면?\n  - 만능 객체가 되려 한다.\n  - 다른 객체에게 의뢰한다.\n\n> 다른 객체에게 의뢰하는 것 = 다른 객체에게 메세지를 보내는 것\n\n- 메세지 - 의뢰할 내용\n- 오퍼레이션 - 메시지를 수신할 객체가 제공하는 서비스\n  - 객체를 사용하기 위해 외부에 노출되는 서비스 메뉴판 느낌\n  - 오퍼레이터가 런타임에 어떤 메소드랑 매핑될지 결정하는 걸 `동적바인딩`이라고 한다.\n- 메소드 - 오퍼레이션과 연결될 실제 처리기\n\n> - 추상클래스를 상속받거나 인터페이스를 상속받는 이유\n>   - 오퍼레이션과 메서드를 분리해서 런타임에 원하는 것을 사용하기 위함 (OCP)\n\n## 의존성(Dependency)\n\n- 가장 중요한 격리의 문제\n- 다른 사람의 문제로 내가 영향을 받는 것\n\n<aside>\n\n다른 객체를 알고 의뢰를 해야 하지만, 나에게 영향은 없어야 한다. (모순적이기에 어렵다.)\n\n디자인(설계)에서 각각 의존성을 적절히 가질 수 있도록 적당한 `균형점`을 찾아야 한다.\n\n</aside>\n\n### 의존성의 종류\n\n1. 객체 생명 주기 전체에 걸친 의존성\n   - 상속(extends)\n   - 연관(association)\n2. 각 오퍼레이션 실행 시 임시적인 의존성\n   - 의존(dependency)\n\n<aside>\n\n의존성이 높다면?\n\n- 수정 여파 규모 증가\n- 수정하기 어려운 구조 생성\n- 순환 의존성\n  - A가 의존한 B가 의존한 C가 의존한 D에서 문제 발생\n  - 타이틀을 바꿨는데 게시판이 먹통\n\n</aside>\n\n<aside>\n\n객체지향을 배우는 이유는 격리구간을 세우고 의존성을 관리하기 위해서다. 변화에 대해 격리를 하기 위해.\n\n</aside>\n\n## 의존성 역전 (Dependency Inversion)\n\n- 다운캐스팅(DIP) 금지\n- Polymorphism(추상인터페이스) 사용\n\n```javascript\nconst Worker = class {\n  run() {\n    console.log(\"working\");\n  }\n  print() {\n    this.run();\n  }\n};\n\nconst HardWorker = class extends Worker {\n  run() {\n    console.log(\"HardWorking\");\n  }\n};\n\nconst worker = new HardWorker();\n\nconst Manager = class {\n  #workers;\n  constructor(...workers) {\n    if (workers.every((w) => w instanceof Worker)) this.#workers = workers;\n    else throw \"invalid workers\";\n  }\n  doWork() {\n    this.#wokers.forEach((w) => w.run());\n  }\n};\n\nconst manager = new Manager(new Worker(), new HardWorker());\nmanager.doWork(); // working, hardworking\n```\n\n- 개방폐쇄원칙(OCP) 준수\n  - Worker로 부터 확장된 객체를 더 만들 수 있음 ⇒ Open\n  - 확장할 때마다 코드를 수정할 필요 없음 ⇒ Closed\n    - 확장된 객체(HardWorker)가 아닌 추상화된 객체(Worker)를 사용\n- 개방폐쇄원칙(OCP)을 준수하면 의존성 역전 원칙(DIP)은 자연스럽게 달성\n  - OCP와 DIP는 깊은 관계\n  - OCP가 안되면 DIP가 될 리 없다.\n\n## 제어역전 (Inversion of Control)\n\n- 객체지향에서 도달해야 할 궁극적인 목표.\n- 나머지 원칙들을 모두 준수해야 달성할 수 있음.\n\n### 개념\n\n1. Control = flow control(흐름 제어)\n2. 광의에서 흐름 제어 = 프로그램 실행 통제\n3. 동기 흐름제어, 비동기 흐름제어 등\n\n### 문제점\n\n- 흐름 제어는 상태와 결합하여 진행됨\n- 상태 통제와 흐름 제어 = 알고리즘\n- 변화에 취약하고 구현하기도 어려움\n  - 함수 1개가 120줄이면.. 경우의 수가 수백가지.. 예측이 힘들다.\n  - 예측도 힘든데 유지보수는 더 어려움.\n\n### 대안\n\n- 제어를 추상화하고\n- 개별 제어의 차이점만 외부에서 주입받는다.\n  - 아래 예제를 가지고 자세히 봐보자.\n\n```javascript\nconst Renderer = class {\n  #view = null;\n  #base = null;\n\n  constructor(baseElement) {\n    this.#base = baseElement;\n  }\n\n  set view(v) {\n    if (v instanceof View) this.#view = v;\n    else throw `invalid view: ${v}`;\n  }\n\n  render(data) {\n    const base = this.#base,\n      view = this.#view;\n\n    if (!base || !view) throw \"no base or no view\";\n\n    let target = base.firstElementChild;\n\n    do base.removeChild(target);\n    while ((target = target.nextElementSibling));\n\n    base.appendChild(view.getElement(data));\n    view.initAni();\n    view.startAni();\n  }\n};\n\nconst View = class {\n  getElement(data) {\n    throw `override!`;\n  }\n  initAni() {\n    throw \"override!\";\n  }\n  startAni() {\n    throw \"override!\";\n  }\n};\n\nconst renderer = new Renderer(document.body);\nrenderer.view = new (class extends View {\n  #el;\n  getElement(data) {\n    this.#el = document.createElement(\"div\");\n    this.#el.innerHTML = `<h2>${data.title}</h2><p>${data.description}</p>`;\n    this.#el.style.cssText = `width:100%;background:${data.background}`;\n    return this.#el;\n  }\n  initAni() {\n    const style = this.#el.style;\n    style.marginLeft = \"100%\";\n    style.transition = \"0.3s\";\n  }\n  startAni() {\n    requestAnimationFrame(() => (this.#el.style.marginLeft = 0));\n  }\n})();\n\nrenderer.render({\n  title: \"title test\",\n  description: \"contents.........\",\n  background: \"#ffffaa\",\n});\n```\n\n- renderer에서만 `제어`를 처리함.\n  - 얘만 고치면 됨.\n- 제어 외의 view는 주입(공급)받아 사용.\n\n> - `Framework`\n>   - 제어 역전을 사용.\n>   - 일부의 기능들을 정의 ⇒ 그걸 모아서 실행(제어) 시켜줌\n> - `Library`\n>   - 제어하지 않음.\n>   - 기능을 가져다 사용\n","coverImage":"/assets/blog/oop-javascript/cover.png","excerpt":"객체지향 프로그래밍의 이론과 궁극적인 목표에 대해 정리한 내용입니다.","reference":[{"exposed":"코드스피츠 86 객체지향 자바스크립트 - 1회차","url":"https://www.youtube.com/watch?v=E9NZ0YEZrYU"}],"tags":["JavaScript","OOP","코드스피츠"]}},"__N_SSG":true}